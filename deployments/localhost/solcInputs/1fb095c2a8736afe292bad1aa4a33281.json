{
  "language": "Solidity",
  "sources": {
    "contracts/access/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ncontract Governable {\n    address public gov;\n    constructor() public {\n        gov = msg.sender;\n    }\n    modifier onlyGov() {\n        require(msg.sender == gov, \"Governable: forbidden\");\n        _;\n    }\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n}\n"
    },
    "contracts/peripherals/Reader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../access/Governable.sol\";\nimport \"../core/storage/ReaderStorage.sol\";\ncontract Reader is Governable,ReaderStorage {\n    function setConfig(bool _hasMaxGlobalShortSizes) public onlyGov {\n        hasMaxGlobalShortSizes = _hasMaxGlobalShortSizes;\n    }\n    /* views */\n    function getMaxAmountIn(IVault _vault, address _tokenIn, address _tokenOut) public view returns (uint256) {\n        uint256 priceIn = _vault.getMinPrice(_tokenIn);\n        uint256 priceOut = _vault.getMaxPrice(_tokenOut);\n        uint256 tokenInDecimals = _vault.tokenDecimals(_tokenIn);\n        uint256 tokenOutDecimals = _vault.tokenDecimals(_tokenOut);\n        uint256 amountIn;\n        {\n            uint256 poolAmount = _vault.poolAmounts(_tokenOut);\n            uint256 reservedAmount = _vault.reservedAmounts(_tokenOut);\n            uint256 bufferAmount = _vault.bufferAmounts(_tokenOut);\n            uint256 subAmount = reservedAmount > bufferAmount ? reservedAmount : bufferAmount;\n            if (subAmount >= poolAmount) {\n                return 0;\n            }\n            uint256 availableAmount = poolAmount.sub(subAmount);\n            amountIn = availableAmount.mul(priceOut).div(priceIn).mul(10 ** tokenInDecimals).div(10 ** tokenOutDecimals);\n        }\n        uint256 maxUsdmAmount = _vault.maxUsdmAmounts(_tokenIn);\n        if (maxUsdmAmount != 0) {\n            if (maxUsdmAmount < _vault.usdmAmounts(_tokenIn)) {\n                return 0;\n            }\n            uint256 maxAmountIn = maxUsdmAmount.sub(_vault.usdmAmounts(_tokenIn));\n            maxAmountIn = maxAmountIn.mul(10 ** tokenInDecimals).div(10 ** USDM_DECIMALS);\n            maxAmountIn = maxAmountIn.mul(PRICE_PRECISION).div(priceIn);\n            if (amountIn > maxAmountIn) {\n                return maxAmountIn;\n            }\n        }\n        return amountIn;\n    }\n    function getAmountOut(IVault _vault, address _tokenIn, address _tokenOut, uint256 _amountIn) public view returns (uint256, uint256) {\n        uint256 priceIn = _vault.getMinPrice(_tokenIn);\n        uint256 tokenInDecimals = _vault.tokenDecimals(_tokenIn);\n        uint256 tokenOutDecimals = _vault.tokenDecimals(_tokenOut);\n        uint256 feeBasisPoints;\n        {\n            uint256 usdmAmount = _amountIn.mul(priceIn).div(PRICE_PRECISION);\n            usdmAmount = usdmAmount.mul(10 ** USDM_DECIMALS).div(10 ** tokenInDecimals);\n            bool isStableSwap = _vault.stableTokens(_tokenIn) && _vault.stableTokens(_tokenOut);\n            uint256 baseBps = isStableSwap ? _vault.stableSwapFeeBasisPoints() : _vault.swapFeeBasisPoints();\n            uint256 taxBps = isStableSwap ? _vault.stableTaxBasisPoints() : _vault.taxBasisPoints();\n            uint256 feesBasisPoints0 = _vault.getFeeBasisPoints(_tokenIn, usdmAmount, baseBps, taxBps, true);\n            uint256 feesBasisPoints1 = _vault.getFeeBasisPoints(_tokenOut, usdmAmount, baseBps, taxBps, false);\n            feeBasisPoints = feesBasisPoints0 > feesBasisPoints1 ? feesBasisPoints0 : feesBasisPoints1;\n        }\n        uint256 priceOut = _vault.getMaxPrice(_tokenOut);\n        uint256 amountOut = _amountIn.mul(priceIn).div(priceOut);\n        amountOut = amountOut.mul(10 ** tokenOutDecimals).div(10 ** tokenInDecimals);\n        uint256 amountOutAfterFees = amountOut.mul(BASIS_POINTS_DIVISOR.sub(feeBasisPoints)).div(BASIS_POINTS_DIVISOR);\n        uint256 feeAmount = amountOut.sub(amountOutAfterFees);\n        return (amountOutAfterFees, feeAmount);\n    }\n    function getFeeBasisPoints(IVault _vault, address _tokenIn, address _tokenOut, uint256 _amountIn) public view returns (uint256, uint256, uint256) {\n        uint256 priceIn = _vault.getMinPrice(_tokenIn);\n        uint256 tokenInDecimals = _vault.tokenDecimals(_tokenIn);\n        uint256 usdmAmount = _amountIn.mul(priceIn).div(PRICE_PRECISION);\n        usdmAmount = usdmAmount.mul(10 ** USDM_DECIMALS).div(10 ** tokenInDecimals);\n        bool isStableSwap = _vault.stableTokens(_tokenIn) && _vault.stableTokens(_tokenOut);\n        uint256 baseBps = isStableSwap ? _vault.stableSwapFeeBasisPoints() : _vault.swapFeeBasisPoints();\n        uint256 taxBps = isStableSwap ? _vault.stableTaxBasisPoints() : _vault.taxBasisPoints();\n        uint256 feesBasisPoints0 = _vault.getFeeBasisPoints(_tokenIn, usdmAmount, baseBps, taxBps, true);\n        uint256 feesBasisPoints1 = _vault.getFeeBasisPoints(_tokenOut, usdmAmount, baseBps, taxBps, false);\n        uint256 feeBasisPoints = feesBasisPoints0 > feesBasisPoints1 ? feesBasisPoints0 : feesBasisPoints1;\n        return (feeBasisPoints, feesBasisPoints0, feesBasisPoints1);\n    }\n    function getFees(address _vault, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amounts[i] = IVault(_vault).feeReserves(_tokens[i]);\n        }\n        return amounts;\n    }\n    function getTotalStaked(address[] memory _yieldTokens) public view returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](_yieldTokens.length);\n        for (uint256 i = 0; i < _yieldTokens.length; i++) {\n            IYieldToken yieldToken = IYieldToken(_yieldTokens[i]);\n            amounts[i] = yieldToken.totalStaked();\n        }\n        return amounts;\n    }\n    function getStakingInfo(address _account, address[] memory _yieldTrackers) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory amounts = new uint256[](_yieldTrackers.length * propsLength);\n        for (uint256 i = 0; i < _yieldTrackers.length; i++) {\n            IYieldTracker yieldTracker = IYieldTracker(_yieldTrackers[i]);\n            amounts[i * propsLength] = yieldTracker.claimable(_account);\n            amounts[i * propsLength + 1] = yieldTracker.getTokensPerInterval();\n        }\n        return amounts;\n    }\n    function getVestingInfo(address _account, address[] memory _vesters) public view returns (uint256[] memory) {\n        uint256 propsLength = 7;\n        uint256[] memory amounts = new uint256[](_vesters.length * propsLength);\n        for (uint256 i = 0; i < _vesters.length; i++) {\n            IVester vester = IVester(_vesters[i]);\n            amounts[i * propsLength] = vester.pairAmounts(_account);\n            amounts[i * propsLength + 1] = vester.getVestedAmount(_account);\n            amounts[i * propsLength + 2] = IERC20(_vesters[i]).balanceOf(_account);\n            amounts[i * propsLength + 3] = vester.claimedAmounts(_account);\n            amounts[i * propsLength + 4] = vester.claimable(_account);\n            amounts[i * propsLength + 5] = vester.getMaxVestableAmount(_account);\n            amounts[i * propsLength + 6] = vester.getCombinedAverageStakedAmount(_account);\n        }\n        return amounts;\n    }\n    function getPairInfo(address _factory, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 inputLength = 2;\n        uint256 propsLength = 2;\n        uint256[] memory amounts = new uint256[](_tokens.length / inputLength * propsLength);\n        for (uint256 i = 0; i < _tokens.length / inputLength; i++) {\n            address token0 = _tokens[i * inputLength];\n            address token1 = _tokens[i * inputLength + 1];\n            address pair = IPancakeFactory(_factory).getPair(token0, token1);\n            amounts[i * propsLength] = IERC20(token0).balanceOf(pair);\n            amounts[i * propsLength + 1] = IERC20(token1).balanceOf(pair);\n        }\n        return amounts;\n    }\n    function getFundingRates(address _vault, address _weth, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory fundingRates = new uint256[](_tokens.length * propsLength);\n        IVault vault = IVault(_vault);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            uint256 fundingRateFactor = vault.stableTokens(token) ? vault.stableFundingRateFactor() : vault.fundingRateFactor();\n            uint256 reservedAmount = vault.reservedAmounts(token);\n            uint256 poolAmount = vault.poolAmounts(token);\n            if (poolAmount > 0) {\n                fundingRates[i * propsLength] = fundingRateFactor.mul(reservedAmount).div(poolAmount);\n            }\n            if (vault.cumulativeFundingRates(token) > 0) {\n                uint256 nextRate = vault.getNextFundingRate(token);\n                uint256 baseRate = vault.cumulativeFundingRates(token);\n                fundingRates[i * propsLength + 1] = baseRate.add(nextRate);\n            }\n        }\n        return fundingRates;\n    }\n    function getTokenSupply(IERC20 _token, address[] memory _excludedAccounts) public view returns (uint256) {\n        uint256 supply = _token.totalSupply();\n        for (uint256 i = 0; i < _excludedAccounts.length; i++) {\n            address account = _excludedAccounts[i];\n            uint256 balance = _token.balanceOf(account);\n            supply = supply.sub(balance);\n        }\n        return supply;\n    }\n    function getTotalBalance(IERC20 _token, address[] memory _accounts) public view returns (uint256) {\n        uint256 totalBalance = 0;\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            uint256 balance = _token.balanceOf(account);\n            totalBalance = totalBalance.add(balance);\n        }\n        return totalBalance;\n    }\n    function getTokenBalances(address _account, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256[] memory balances = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                balances[i] = _account.balance;\n                continue;\n            }\n            balances[i] = IERC20(token).balanceOf(_account);\n        }\n        return balances;\n    }\n    function getTokenBalancesWithSupplies(address _account, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 2;\n        uint256[] memory balances = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                balances[i * propsLength] = _account.balance;\n                balances[i * propsLength + 1] = 0;\n                continue;\n            }\n            balances[i * propsLength] = IERC20(token).balanceOf(_account);\n            balances[i * propsLength + 1] = IERC20(token).totalSupply();\n        }\n        return balances;\n    }\n    function getPrices(IVaultPriceFeed _priceFeed, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 6;\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            amounts[i * propsLength] = _priceFeed.getPrice(token, true, true, false);\n            amounts[i * propsLength + 1] = _priceFeed.getPrice(token, false, true, false);\n            amounts[i * propsLength + 2] = _priceFeed.getPrimaryPrice(token, true);\n            amounts[i * propsLength + 3] = _priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 4] = _priceFeed.isAdjustmentAdditive(token) ? 1 : 0;\n            amounts[i * propsLength + 5] = _priceFeed.adjustmentBasisPoints(token);\n        }\n        return amounts;\n    }\n    function getVaultTokenInfo(address _vault, address _weth, uint256 _usdmAmount, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 10;\n        IVault vault = IVault(_vault);\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(vault.priceFeed());\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.usdmAmounts(token);\n            amounts[i * propsLength + 3] = vault.getRedemptionAmount(token, _usdmAmount);\n            amounts[i * propsLength + 4] = vault.tokenWeights(token);\n            amounts[i * propsLength + 5] = vault.getMinPrice(token);\n            amounts[i * propsLength + 6] = vault.getMaxPrice(token);\n            amounts[i * propsLength + 7] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 8] = priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 9] = priceFeed.getPrimaryPrice(token, true);\n        }\n        return amounts;\n    }\n    function getFullVaultTokenInfo(address _vault, address _weth, uint256 _usdmAmount, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 12;\n        IVault vault = IVault(_vault);\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(vault.priceFeed());\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.usdmAmounts(token);\n            amounts[i * propsLength + 3] = vault.getRedemptionAmount(token, _usdmAmount);\n            amounts[i * propsLength + 4] = vault.tokenWeights(token);\n            amounts[i * propsLength + 5] = vault.bufferAmounts(token);\n            amounts[i * propsLength + 6] = vault.maxUsdmAmounts(token);\n            amounts[i * propsLength + 7] = vault.getMinPrice(token);\n            amounts[i * propsLength + 8] = vault.getMaxPrice(token);\n            amounts[i * propsLength + 9] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 10] = priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 11] = priceFeed.getPrimaryPrice(token, true);\n        }\n        return amounts;\n    }\n    function getVaultTokenInfoV2(address _vault, address _weth, uint256 _usdmAmount, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 14;\n        IVault vault = IVault(_vault);\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(vault.priceFeed());\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            uint256 maxGlobalShortSize = hasMaxGlobalShortSizes ? vault.maxGlobalShortSizes(token) : 0;\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.usdmAmounts(token);\n            amounts[i * propsLength + 3] = vault.getRedemptionAmount(token, _usdmAmount);\n            amounts[i * propsLength + 4] = vault.tokenWeights(token);\n            amounts[i * propsLength + 5] = vault.bufferAmounts(token);\n            amounts[i * propsLength + 6] = vault.maxUsdmAmounts(token);\n            amounts[i * propsLength + 7] = vault.globalShortSizes(token);\n            amounts[i * propsLength + 8] = maxGlobalShortSize;\n            amounts[i * propsLength + 9] = vault.getMinPrice(token);\n            amounts[i * propsLength + 10] = vault.getMaxPrice(token);\n            amounts[i * propsLength + 11] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 12] = priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 13] = priceFeed.getPrimaryPrice(token, true);\n        }\n        return amounts;\n    }\n    function getPositions(address _vault, address _account, address[] memory _collateralTokens, address[] memory _indexTokens, bool[] memory _isLong) public view returns(uint256[] memory) {\n        uint256[] memory amounts = new uint256[](_collateralTokens.length * POSITION_PROPS_LENGTH);\n        for (uint256 i = 0; i < _collateralTokens.length; i++) {\n            {\n            (uint256 size,\n             uint256 collateral,\n             uint256 averagePrice,\n             uint256 entryFundingRate,\n             /* reserveAmount */,\n             uint256 realisedPnl,\n             bool hasRealisedProfit,\n             uint256 lastIncreasedTime) = IVault(_vault).getPosition(_account, _collateralTokens[i], _indexTokens[i], _isLong[i]);\n\n            amounts[i * POSITION_PROPS_LENGTH] = size;\n            amounts[i * POSITION_PROPS_LENGTH + 1] = collateral;\n            amounts[i * POSITION_PROPS_LENGTH + 2] = averagePrice;\n            amounts[i * POSITION_PROPS_LENGTH + 3] = entryFundingRate;\n            amounts[i * POSITION_PROPS_LENGTH + 4] = hasRealisedProfit ? 1 : 0;\n            amounts[i * POSITION_PROPS_LENGTH + 5] = realisedPnl;\n            amounts[i * POSITION_PROPS_LENGTH + 6] = lastIncreasedTime;\n            }\n            uint256 size = amounts[i * POSITION_PROPS_LENGTH];\n            uint256 averagePrice = amounts[i * POSITION_PROPS_LENGTH + 2];\n            uint256 lastIncreasedTime = amounts[i * POSITION_PROPS_LENGTH + 6];\n            if (averagePrice > 0) {\n                (bool hasProfit, uint256 delta) = IVault(_vault).getDelta(_indexTokens[i], size, averagePrice, _isLong[i], lastIncreasedTime);\n                amounts[i * POSITION_PROPS_LENGTH + 7] = hasProfit ? 1 : 0;\n                amounts[i * POSITION_PROPS_LENGTH + 8] = delta;\n            }\n        }\n        return amounts;\n    }\n}\n"
    },
    "contracts/core/storage/ReaderStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../core/interfaces/IVault.sol\";\nimport \"../../core/interfaces/IVaultPriceFeed.sol\";\nimport \"../../tokens/interfaces/IYieldTracker.sol\";\nimport \"../../tokens/interfaces/IYieldToken.sol\";\nimport \"../../amm/interfaces/IPancakeFactory.sol\";\nimport \"../../staking/interfaces/IVester.sol\";\n\nabstract contract ReaderStorage {\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant POSITION_PROPS_LENGTH = 9;\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant USDM_DECIMALS = 18;\n    bool public hasMaxGlobalShortSizes;\n\n    using SafeMath for uint256;\n}\n"
    },
    "contracts/libraries/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/core/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./IVaultUtils.sol\";\ninterface IVault {\n    function withdrawFees(address _token, address _receiver) external returns (uint256);\n    function directPoolDeposit(address _token) external;\n    function buyUSDM(address _token, address _receiver) external returns (uint256);\n    function sellUSDM(address _token, address _receiver) external returns (uint256);\n    function swap(address _tokenIn, address _tokenOut, address _receiver) external returns (uint256);\n    function increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external;\n    function decreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) external returns (uint256);\n    function validateLiquidation(address _account, address _collateralToken, address _indexToken, bool _isLong, bool _raise) external view returns (uint256, uint256);\n    function liquidatePosition(address _account, address _collateralToken, address _indexToken, bool _isLong, address _feeReceiver) external;\n\n    function tokenToUsdMin(address _token, uint256 _tokenAmount) external view returns (uint256);\n    function priceFeed() external view returns (address);\n    function fundingRateFactor() external view returns (uint256);\n    function stableFundingRateFactor() external view returns (uint256);\n    function cumulativeFundingRates(address _token) external view returns (uint256);\n    function getNextFundingRate(address _token) external view returns (uint256);\n    function getFeeBasisPoints(address _token, uint256 _usdmDelta, uint256 _feeBasisPoints, uint256 _taxBasisPoints, bool _increment) external view returns (uint256);\n    function liquidationFeeUsd() external view returns (uint256);\n    function taxBasisPoints() external view returns (uint256);\n    function stableTaxBasisPoints() external view returns (uint256);\n    function mintBurnFeeBasisPoints() external view returns (uint256);\n    function swapFeeBasisPoints() external view returns (uint256);\n    function stableSwapFeeBasisPoints() external view returns (uint256);\n    function marginFeeBasisPoints() external view returns (uint256);\n    function allWhitelistedTokensLength() external view returns (uint256);\n    function allWhitelistedTokens(uint256) external view returns (address);\n    function whitelistedTokens(address _token) external view returns (bool);\n    function stableTokens(address _token) external view returns (bool);\n    function shortableTokens(address _token) external view returns (bool);\n    function feeReserves(address _token) external view returns (uint256);\n    function globalShortSizes(address _token) external view returns (uint256);\n    function globalShortAveragePrices(address _token) external view returns (uint256);\n    function maxGlobalShortSizes(address _token) external view returns (uint256);\n    function tokenDecimals(address _token) external view returns (uint256);\n    function tokenWeights(address _token) external view returns (uint256);\n    function guaranteedUsd(address _token) external view returns (uint256);\n    function poolAmounts(address _token) external view returns (uint256);\n    function bufferAmounts(address _token) external view returns (uint256);\n    function reservedAmounts(address _token) external view returns (uint256);\n    function usdmAmounts(address _token) external view returns (uint256);\n    function maxUsdmAmounts(address _token) external view returns (uint256);\n    function getRedemptionAmount(address _token, uint256 _usdmAmount) external view returns (uint256);\n    function getMaxPrice(address _token) external view returns (uint256);\n    function getMinPrice(address _token) external view returns (uint256);\n    function getDelta(address _indexToken, uint256 _size, uint256 _averagePrice, bool _isLong, uint256 _lastIncreasedTime) external view returns (bool, uint256);\n    function getPosition(address _account, address _collateralToken, address _indexToken, bool _isLong) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256);\n    function isInitialized() external view returns (bool);\n    function isSwapEnabled() external view returns (bool);\n    function isLeverageEnabled() external view returns (bool);\n    function router() external view returns (address);\n    function usdm() external view returns (address);\n    function gov() external view returns (address);\n    function whitelistedTokenCount() external view returns (uint256);\n    function maxLeverage() external view returns (uint256);\n    function minProfitTime() external view returns (uint256);\n    function hasDynamicFees() external view returns (bool);\n    function fundingInterval() external view returns (uint256);\n    function totalTokenWeights() external view returns (uint256);\n    function getTargetUsdmAmount(address _token) external view returns (uint256);\n    function inManagerMode() external view returns (bool);\n    function inPrivateLiquidationMode() external view returns (bool);\n    function maxGasPrice() external view returns (uint256);\n    function approvedRouters(address _account, address _router) external view returns (bool);\n    function isLiquidator(address _account) external view returns (bool);\n    function isManager(address _account) external view returns (bool);\n    function minProfitBasisPoints(address _token) external view returns (uint256);\n    function tokenBalances(address _token) external view returns (uint256);\n    function lastFundingTimes(address _token) external view returns (uint256);\n\n    function setMaxLeverage(uint256 _maxLeverage) external;\n    function setInManagerMode(bool _inManagerMode) external;\n    function setManager(address _manager, bool _isManager) external;\n    function setIsSwapEnabled(bool _isSwapEnabled) external;\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external;\n    function setMaxGasPrice(uint256 _maxGasPrice) external;\n    function setUsdmAmount(address _token, uint256 _amount) external;\n    function setBufferAmount(address _token, uint256 _amount) external;\n    function setMaxGlobalShortSize(address _token, uint256 _amount) external;\n    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external;\n    function setLiquidator(address _liquidator, bool _isActive) external;\n    function setFundingRate(uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external;\n    function setFees(uint256 _taxBasisPoints, uint256 _stableTaxBasisPoints, uint256 _mintBurnFeeBasisPoints, uint256 _swapFeeBasisPoints, uint256 _stableSwapFeeBasisPoints, uint256 _marginFeeBasisPoints, uint256 _liquidationFeeUsd, uint256 _minProfitTime, bool _hasDynamicFees) external;\n    function setTokenConfig(address _token, uint256 _tokenDecimals, uint256 _redemptionBps, uint256 _minProfitBps, uint256 _maxUsdmAmount, bool _isStable, bool _isShortable) external;\n    function setPriceFeed(address _priceFeed) external;\n    function setVaultUtils(IVaultUtils _vaultUtils) external;\n    function setError(uint256 _errorCode, string calldata _error) external;\n}\n"
    },
    "contracts/core/interfaces/IVaultPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IVaultPriceFeed {\n    function adjustmentBasisPoints(address _token) external view returns (uint256);\n    function isAdjustmentAdditive(address _token) external view returns (bool);\n    function setAdjustment(address _token, bool _isAdditive, uint256 _adjustmentBps) external;\n    function setUseV2Pricing(bool _useV2Pricing) external;\n    function setIsAmmEnabled(bool _isEnabled) external;\n    function setIsSecondaryPriceEnabled(bool _isEnabled) external;\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints) external;\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints) external;\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external;\n    function setPriceSampleSpace(uint256 _priceSampleSpace) external;\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation) external;\n    function getPrice(address _token, bool _maximise, bool _includeAmmPrice, bool _useSwapPricing) external view returns (uint256);\n    function getAmmPrice(address _token) external view returns (uint256);\n    function getLatestPrimaryPrice(address _token) external view returns (uint256);\n    function getPrimaryPrice(address _token, bool _maximise) external view returns (uint256);\n    function setTokenConfig(address _token, address _priceFeed, uint256 _priceDecimals, bool _isStrictStable) external;\n}\n"
    },
    "contracts/tokens/interfaces/IYieldTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IYieldTracker {\n    function claim(address _account, address _receiver) external returns (uint256);\n    function updateRewards(address _account) external;\n    function getTokensPerInterval() external view returns (uint256);\n    function claimable(address _account) external view returns (uint256);\n}"
    },
    "contracts/tokens/interfaces/IYieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IYieldToken {\n    function totalStaked() external view returns (uint256);\n    function stakedBalance(address _account) external view returns (uint256);\n    function removeAdmin(address _account) external;\n}"
    },
    "contracts/amm/interfaces/IPancakeFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPancakeFactory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n"
    },
    "contracts/staking/interfaces/IVester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IVester {\n    function rewardTracker() external view returns (address);\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n    function claimable(address _account) external view returns (uint256);\n    function cumulativeClaimAmounts(address _account) external view returns (uint256);\n    function claimedAmounts(address _account) external view returns (uint256);\n    function pairAmounts(address _account) external view returns (uint256);\n    function getVestedAmount(address _account) external view returns (uint256);\n    function transferredAverageStakedAmounts(address _account) external view returns (uint256);\n    function transferredCumulativeRewards(address _account) external view returns (uint256);\n    function cumulativeRewardDeductions(address _account) external view returns (uint256);\n    function bonusRewards(address _account) external view returns (uint256);\n    function transferStakeValues(address _sender, address _receiver) external;\n    function setTransferredAverageStakedAmounts(address _account, uint256 _amount) external;\n    function setTransferredCumulativeRewards(address _account, uint256 _amount) external;\n    function setCumulativeRewardDeductions(address _account, uint256 _amount) external;\n    function setBonusRewards(address _account, uint256 _amount) external;\n    function getMaxVestableAmount(address _account) external view returns (uint256);\n    function getCombinedAverageStakedAmount(address _account) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IVaultUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IVaultUtils {\n    function updateCumulativeFundingRate(address _collateralToken, address _indexToken) external returns (bool);\n    function validateIncreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external view;\n    function validateDecreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) external view;\n    function validateLiquidation(address _account, address _collateralToken, address _indexToken, bool _isLong, bool _raise) external view returns (uint256, uint256);\n    function getEntryFundingRate(address _collateralToken, address _indexToken, bool _isLong) external view returns (uint256);\n    function getPositionFee(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _sizeDelta) external view returns (uint256);\n    function getFundingFee(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _size, uint256 _entryFundingRate) external view returns (uint256);\n    function getBuyUsdmFeeBasisPoints(address _token, uint256 _usdmAmount) external view returns (uint256);\n    function getSellUsdmFeeBasisPoints(address _token, uint256 _usdmAmount) external view returns (uint256);\n    function getSwapFeeBasisPoints(address _tokenIn, address _tokenOut, uint256 _usdmAmount) external view returns (uint256);\n    function getFeeBasisPoints(address _token, uint256 _usdmDelta, uint256 _feeBasisPoints, uint256 _taxBasisPoints, bool _increment) external view returns (uint256);\n}\n"
    },
    "contracts/core/storage/TimelockStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\nimport \"../../peripherals/interfaces/ITimelockTarget.sol\";\nimport \"../../peripherals/interfaces/ITimelock.sol\";\nimport \"../../peripherals/interfaces/IHandlerTarget.sol\";\n\nimport \"../../access/interfaces/IAdmin.sol\";\nimport \"../../core/interfaces/IVault.sol\";\nimport \"../../core/interfaces/IVaultUtils.sol\";\nimport \"../../core/interfaces/IMlpManager.sol\";\nimport \"../../referrals/interfaces/IReferralStorage.sol\";\nimport \"../../tokens/interfaces/IYieldToken.sol\";\nimport \"../../tokens/interfaces/IBaseToken.sol\";\nimport \"../../tokens/interfaces/IMintable.sol\";\nimport \"../../tokens/interfaces/IUSDM.sol\";\nimport \"../../staking/interfaces/IVester.sol\";\nimport \"../../libraries/token/IERC20.sol\";\n\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nabstract contract TimelockStorage is ITimelock {\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant MAX_BUFFER = 5 days;\n    uint256 public constant MAX_FUNDING_RATE_FACTOR = 200; // 0.02%\n    uint256 public constant MAX_LEVERAGE_VALIDATION = 500000; // 50x\n    uint256 public buffer;\n    uint256 public maxTokenSupply;\n    uint256 public marginFeeBasisPoints;\n    uint256 public maxMarginFeeBasisPoints;\n    bool public shouldToggleIsLeverageEnabled;\n    address public admin;\n    address public tokenManager;\n    address public mintReceiver;\n    address public mlpManager;\n    mapping (bytes32 => uint256) public pendingActions;\n    mapping (address => bool) public isHandler;\n    mapping (address => bool) public isKeeper;\n\n    using SafeMath for uint256;\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Timelock: forbidden\");\n        _;\n    }\n    modifier onlyHandlerAndAbove() {\n        require(msg.sender == admin || isHandler[msg.sender], \"Timelock: forbidden\");\n        _;\n    }\n    modifier onlyKeeperAndAbove() {\n        require(msg.sender == admin || isHandler[msg.sender] || isKeeper[msg.sender], \"Timelock: forbidden\");\n        _;\n    }\n    modifier onlyTokenManager() {\n        require(msg.sender == tokenManager, \"Timelock: forbidden\");\n        _;\n    }\n}\n"
    },
    "contracts/peripherals/interfaces/ITimelockTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface ITimelockTarget {\n    function setGov(address _gov) external;\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/peripherals/interfaces/ITimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface ITimelock {\n    function setAdmin(address _admin) external;\n    function enableLeverage(address _vault) external;\n    function disableLeverage(address _vault) external;\n    function setIsLeverageEnabled(address _vault, bool _isLeverageEnabled) external;\n    function signalSetGov(address _target, address _gov) external;\n}\n"
    },
    "contracts/peripherals/interfaces/IHandlerTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IHandlerTarget {\n    function isHandler(address _account) external returns (bool);\n    function setHandler(address _handler, bool _isActive) external;\n}\n"
    },
    "contracts/access/interfaces/IAdmin.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IAdmin {\n    function setAdmin(address _admin) external;\n}\n"
    },
    "contracts/core/interfaces/IMlpManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IMlpManager {\n    function usdm() external view returns (address);\n    function cooldownDuration() external returns (uint256);\n    function getAumInUsdm(bool maximise) external view returns (uint256);\n    function lastAddedAt(address _account) external returns (uint256);\n    function addLiquidity(address _token, uint256 _amount, uint256 _minUsdm, uint256 _minMlp) external returns (uint256);\n    function addLiquidityForAccount(address _fundingAccount, address _account, address _token, uint256 _amount, uint256 _minUsdm, uint256 _minMlp) external returns (uint256);\n    function removeLiquidity(address _tokenOut, uint256 _mlpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n    function removeLiquidityForAccount(address _account, address _tokenOut, uint256 _mlpAmount, uint256 _minOut, address _receiver) external returns (uint256);\n}\n"
    },
    "contracts/referrals/interfaces/IReferralStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IReferralStorage {\n    function codeOwners(bytes32 _code) external view returns (address);\n    function getTraderReferralInfo(address _account) external view returns (bytes32, address);\n    function setTraderReferralCode(address _account, bytes32 _code) external;\n    function setTier(uint256 _tierId, uint256 _totalRebate, uint256 _discountShare) external;\n    function setReferrerTier(address _referrer, uint256 _tierId) external;\n    function govSetCodeOwner(bytes32 _code, address _newAccount) external;\n}\n"
    },
    "contracts/tokens/interfaces/IBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IBaseToken {\n    function totalStaked() external view returns (uint256);\n    function stakedBalance(address _account) external view returns (uint256);\n    function removeAdmin(address _account) external;\n    function setInPrivateTransferMode(bool _inPrivateTransferMode) external;\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\n}"
    },
    "contracts/tokens/interfaces/IMintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IMintable {\n    function isMinter(address _account) external returns (bool);\n    function setMinter(address _minter, bool _isActive) external;\n    function mint(address _account, uint256 _amount) external;\n    function burn(address _account, uint256 _amount) external;\n}"
    },
    "contracts/tokens/interfaces/IUSDM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IUSDM {\n    function addVault(address _vault) external;\n    function removeVault(address _vault) external;\n    function mint(address _account, uint256 _amount) external;\n    function burn(address _account, uint256 _amount) external;\n}"
    },
    "contracts/libraries/Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nlibrary Events {\n    /* BasePositionManager Events */\n    event SetDepositFee(uint256 depositFee);\n    event SetIncreasePositionBufferBps(uint256 increasePositionBufferBps);\n    event SetReferralStorage(address referralStorage);\n    event SetAdmin(address admin);\n    event WithdrawFees(address token, address receiver, uint256 amount);\n    event SetMaxGlobalSizes(address[] tokens, uint256[] longSizes, uint256[] shortSizes);\n    event IncreasePositionReferral(address account, uint256 sizeDelta, uint256 marginFeeBasisPoints, bytes32 referralCode, address referrer);\n    event DecreasePositionReferral(address account, uint256 sizeDelta, uint256 marginFeeBasisPoints, bytes32 referralCode, address referrer);\n\n    /*Position Manager Events*/\n    event SetOrderKeeper(address indexed account, bool isActive);\n    event SetLiquidator(address indexed account, bool isActive);\n    event SetPartner(address account, bool isActive);\n    event SetOpened(bool opened);\n    event SetShouldValidateIncreaseOrder(bool shouldValidateIncreaseOrder);\n\n\n    /* Orderbook.sol events */\n    event CreateIncreaseOrder(address indexed account, uint256 orderIndex, address purchaseToken, uint256 purchaseTokenAmount, address collateralToken, address indexToken, uint256 sizeDelta, bool isLong, uint256 triggerPrice, bool triggerAboveThreshold, uint256 executionFee);\n    event CancelIncreaseOrder(address indexed account, uint256 orderIndex, address purchaseToken, uint256 purchaseTokenAmount, address collateralToken, address indexToken, uint256 sizeDelta, bool isLong, uint256 triggerPrice, bool triggerAboveThreshold, uint256 executionFee);\n    event ExecuteIncreaseOrder(address indexed account, uint256 orderIndex, address purchaseToken, uint256 purchaseTokenAmount, address collateralToken, address indexToken, uint256 sizeDelta, bool isLong, uint256 triggerPrice, bool triggerAboveThreshold, uint256 executionFee, uint256 executionPrice);\n    event UpdateIncreaseOrder(address indexed account, uint256 orderIndex, address collateralToken, address indexToken, bool isLong, uint256 sizeDelta, uint256 triggerPrice, bool triggerAboveThreshold);\n    event CreateDecreaseOrder(address indexed account, uint256 orderIndex, address collateralToken, uint256 collateralDelta, address indexToken, uint256 sizeDelta, bool isLong, uint256 triggerPrice, bool triggerAboveThreshold, uint256 executionFee);\n    event CancelDecreaseOrder(address indexed account, uint256 orderIndex, address collateralToken, uint256 collateralDelta, address indexToken, uint256 sizeDelta, bool isLong, uint256 triggerPrice, bool triggerAboveThreshold, uint256 executionFee);\n    event ExecuteDecreaseOrder(address indexed account, uint256 orderIndex, address collateralToken, uint256 collateralDelta, address indexToken, uint256 sizeDelta, bool isLong, uint256 triggerPrice, bool triggerAboveThreshold, uint256 executionFee, uint256 executionPrice);\n    event UpdateDecreaseOrder(address indexed account, uint256 orderIndex, address collateralToken, uint256 collateralDelta, address indexToken, uint256 sizeDelta, bool isLong, uint256 triggerPrice, bool triggerAboveThreshold);\n    event CreateSwapOrder(address indexed account, uint256 orderIndex, address[] path, uint256 amountIn, uint256 minOut, uint256 triggerRatio, bool triggerAboveThreshold, bool shouldUnwrap, uint256 executionFee);\n    event CancelSwapOrder(address indexed account, uint256 orderIndex, address[] path, uint256 amountIn, uint256 minOut, uint256 triggerRatio, bool triggerAboveThreshold, bool shouldUnwrap, uint256 executionFee);\n    event UpdateSwapOrder(address indexed account, uint256 ordexIndex, address[] path, uint256 amountIn, uint256 minOut, uint256 triggerRatio, bool triggerAboveThreshold, bool shouldUnwrap, uint256 executionFee);\n    event ExecuteSwapOrder(address indexed account, uint256 orderIndex, address[] path, uint256 amountIn, uint256 minOut, uint256 amountOut, uint256 triggerRatio, bool triggerAboveThreshold, bool shouldUnwrap, uint256 executionFee);\n    event Initialize(address router, address vault, address weth, address usdm, uint256 minExecutionFee, uint256 minPurchaseTokenAmountUsd);\n    event UpdateMinExecutionFee(uint256 minExecutionFee);\n    event UpdateMinPurchaseTokenAmountUsd(uint256 minPurchaseTokenAmountUsd);\n    event UpdateGov(address gov);\n\n    /* Router.sol events*/\n    event Swap(address account, address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /* ShortsTracker.sol events*/\n    event GlobalShortDataUpdated(address indexed token, uint256 globalShortSize, uint256 globalShortAveragePrice);\n\n    /* Vault.sol events */\n    event BuyUSDM(address account, address token, uint256 tokenAmount, uint256 usdmAmount, uint256 feeBasisPoints);\n    event SellUSDM(address account, address token, uint256 usdmAmount, uint256 tokenAmount, uint256 feeBasisPoints);\n    event Swap(address account, address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, uint256 amountOutAfterFees, uint256 feeBasisPoints);\n    event IncreasePosition(bytes32 key, address account, address collateralToken, address indexToken, uint256 collateralDelta, uint256 sizeDelta, bool isLong, uint256 price, uint256 fee);\n    event DecreasePosition(bytes32 key, address account, address collateralToken, address indexToken, uint256 collateralDelta, uint256 sizeDelta, bool isLong, uint256 price, uint256 fee);\n    event LiquidatePosition(bytes32 key, address account, address collateralToken, address indexToken, bool isLong, uint256 size, uint256 collateral, uint256 reserveAmount, int256 realisedPnl, uint256 markPrice);\n    event UpdatePosition(bytes32 key, uint256 size, uint256 collateral, uint256 averagePrice, uint256 entryFundingRate, uint256 reserveAmount, int256 realisedPnl, uint256 markPrice);\n    event ClosePosition(bytes32 key, uint256 size, uint256 collateral, uint256 averagePrice, uint256 entryFundingRate, uint256 reserveAmount, int256 realisedPnl);\n    event UpdateFundingRate(address token, uint256 fundingRate);\n    event UpdatePnl(bytes32 key, bool hasProfit, uint256 delta);\n    event CollectSwapFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event CollectMarginFees(address token, uint256 feeUsd, uint256 feeTokens);\n    event DirectPoolDeposit(address token, uint256 amount);\n    event IncreasePoolAmount(address token, uint256 amount);\n    event DecreasePoolAmount(address token, uint256 amount);\n    event IncreaseUsdmAmount(address token, uint256 amount);\n    event DecreaseUsdmAmount(address token, uint256 amount);\n    event IncreaseReservedAmount(address token, uint256 amount);\n    event DecreaseReservedAmount(address token, uint256 amount);\n    event IncreaseGuaranteedUsd(address token, uint256 amount);\n    event DecreaseGuaranteedUsd(address token, uint256 amount);\n\n    /* Timelock.sol events */\n    event SignalPendingAction(bytes32 action);\n    event SignalApprove(address token, address spender, uint256 amount, bytes32 action);\n    event SignalWithdrawToken(address target, address token, address receiver, uint256 amount, bytes32 action);\n    event SignalMint(address token, address receiver, uint256 amount, bytes32 action);\n    event SignalSetGov(address target, address gov, bytes32 action);\n    event SignalSetHandler(address target, address handler, bool isActive, bytes32 action);\n    event SignalSetPriceFeed(address vault, address priceFeed, bytes32 action);\n    event SignalRedeemUsdm(address vault, address token, uint256 amount);\n    event SignalVaultSetTokenConfig(address vault, address token, uint256 tokenDecimals, uint256 tokenWeight, uint256 minProfitBps, uint256 maxUsdmAmount, bool isStable, bool isShortable);\n    event ClearAction(bytes32 action);\n\n    /* MlpManager.sol */\n    event AddLiquidity(address account, address token, uint256 amount, uint256 aumInUsdm, uint256 mlpSupply, uint256 usdmAmount, uint256 mintAmount);\n    event RemoveLiquidity(address account, address token, uint256 mlpAmount, uint256 aumInUsdm, uint256 mlpSupply, uint256 usdmAmount, uint256 amountOut);\n\n    /* RewardRouterV2 */\n    event StakeMold(address account, address token, uint256 amount);\n    event UnstakeMold(address account, address token, uint256 amount);\n    event StakeMlp(address account, uint256 amount);\n    event UnstakeMlp(address account, uint256 amount);\n}\n"
    },
    "contracts/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nlibrary Errors {\n    /* Timelock Error Message*/\n    string public constant Timelock_Invalid_Target = \"Timelock: invalid _target\";\n    string public constant Timelock_Invalid_Buffer = \"Timelock: invalid _buffer\";\n    string public constant Timelock_Buffer_Cannot_Be_Decreased = \"Timelock: buffer cannot be decreased\";\n    string public constant Timelock_invalid_maxLeverage = \"Timelock: invalid _maxLeverage\";\n    string public constant Timelock_invalid_fundingRateFactor = \"Timelock: invalid _fundingRateFactor\";\n    string public constant Timelock_invalid_stableFundingRateFactor = \"Timelock: invalid _stableFundingRateFactor\";\n    string public constant Timelock_invalid_minProfitBps = \"Timelock: invalid _minProfitBps\";\n    string public constant Timelock_token_not_yet_whitelisted = \"Timelock: token not yet whitelisted\";\n    string public constant TIMELOCK_INVALID_MAXGASPRICE = \"Invalid _maxGasPrice\";\n    string public constant TIMELOCK_INVALID_LENGTHS = \"Timelock: invalid lengths\";\n    string public constant TIMELOCK_MAXTOKENSUPPLY_EXCEEDED = \"Timelock: maxTokenSupply exceeded\";\n    string public constant TIMELOCK_ACTION_ALREADY_SIGNALLED = \"Timelock: action already signalled\";\n    string public constant TIMELOCK_ACTION_NOT_SIGNALLED = \"Timelock: action not signalled\";\n    string public constant TIMELOCK_ACTION_TIME_NOT_YET_PASSED = \"Timelock: action time not yet passed\";\n    string public constant TIMELOCK_INVALID_ACTION = \"Timelock: invalid _action\";\n    string public constant TIMELOCK_INVALID_BUFFER = \"Timelock: invalid _buffer\";\n\n    /* PriceFeed Error Message*/\n    string public constant PriceFeed_forbidden = \"PriceFeed: forbidden\";\n\n    /* USDM.sol*/\n    string public constant USDM_FORBIDDEN = \"USDM: forbidden\";\n\n    /* BasePositionManagers.sol */\n    string public constant BASEPOSITIONMANAGER_MARK_PRICE_LOWER_THAN_LIMIT      = \"BasePositionManager: mark price lower than limit\";\n    string public constant BASEPOSITIONMANAGER_MARK_PRICE_HIGHER_THAN_LIMIT     = \"BasePositionManager: mark price higher than limit\";\n    string public constant BASEPOSITIONMANAGER_INVALID_PATH_LENGTH              = \"BasePositionManager: invalid _path.length\";\n    string public constant BASEPOSITIONMANAGER_INSUFFICIENT_AMOUNTOUT           = \"BasePositionManager: insufficient amountOut\";\n    string public constant BASEPOSITIONMANAGER_MAX_GLOBAL_LONGS_EXCEEDED        = \"BasePositionManager: max global longs exceeded\";\n    string public constant BASEPOSITIONMANAGER_MAX_GLOBAL_SHORTS_EXCEEDED       = \"BasePositionManager: max global shorts exceeded\";\n    string public constant BASEPOSITIONMANAGER_INVALID_SENDER                   = \"BasePositionManager: invalid sender\";\n\n    /* PositionManager.sol */\n    string public constant POSITIONMANAGER_INVALID_PATH_LENGTH                  = \"PositionManager: invalid _path.length\";\n    string public constant POSITIONMANAGER_INVALID_PATH                         = \"PositionManager: invalid _path\";\n    string public constant POSITIONMANAGER_LONG_DEPOSIT                         = \"PositionManager: long deposit\";\n    string public constant POSITIONMANAGER_LONG_LEVERAGE_DECREASE               = \"PositionManager: long leverage decrease\";\n    string public constant POSITIONMANAGER_FORBIDDEN                            = \"PositionManager: forbidden\";\n\n    /* Router.sol*/\n    string public constant ROUTER_FORBIDDEN                                     = \"Router: forbidden\";\n\n    /* MlpManager.sol */\n    string public constant MLPMANAGER_ACTION_NOT_ENABLED                        = \"MlpManager: action not enabled\";\n    string public constant MLPMANAGER_INVALID_WEIGHT                            = \"MlpManager: invalid weight\";\n    string public constant MLPMANAGER_INVALID_COOLDOWNDURATION                  = \"MlpManager: invalid _cooldownDuration\";\n    string public constant MLPMANAGER_INVALID_AMOUNT                            = \"MlpManager: invalid _amount\";\n    string public constant MLPMANAGER_INSUFFICIENT_USDM_OUTPUT                  = \"MlpManager: insufficient USDM output\";\n    string public constant MLPMANAGER_INSUFFICIENT_MLP_OUTPUT                   = \"MlpManager: insufficient MLP output\";\n    string public constant MLPMANAGER_INVALID_MLPAMOUNT                         = \"MlpManager: invalid _mlpAmount\";\n    string public constant MLPMANAGER_COOLDOWN_DURATION_NOT_YET_PASSED          = \"MlpManager: cooldown duration not yet passed\";\n    string public constant MLPMANAGER_INSUFFICIENT_OUTPUT                       = \"MlpManager: insufficient output\";\n    string public constant MLPMANAGER_FORBIDDEN                                 = \"MlpManager: forbidden\";\n\n    /* ShortsTrack.sol*/\n    string public constant SHORTSTRACKER_FORBIDDEN                              = \"ShortsTracker: forbidden\";\n    string public constant SHORTSTRACKER_INVALID_HANDLER                        = \"ShortsTracker: invalid _handler\";\n    string public constant SHORTSTRACKER_ALREADY_MIGRATED                       = \"ShortsTracker: already migrated\";\n    string public constant SHORTSTRACKER_OVERFLOW                               = \"ShortsTracker: overflow\";\n\n    /* VaultUtils.sol*/\n    string public constant VAULT_LOSSES_EXCEED_COLLATERAL                       = \"Vault: losses exceed collateral\";\n    string public constant VAULT_FEES_EXCEED_COLLATERAL                         = \"Vault: fees exceed collateral\";\n    string public constant VAULT_LIQUIDATION_FEES_EXCEED_COLLATERAL             = \"Vault: liquidation fees exceed collateral\";\n    string public constant VAULT_MAXLEVERAGE_EXCEEDED                           = \"Vault: maxLeverage exceeded\";\n\n    /* VaultPriceFeed.sol*/\n    string public constant VAULTPRICEFEED_FORBIDDEN                             = \"VaultPriceFeed: forbidden\";\n    string public constant VAULTPRICEFEED_ADJUSTMENT_FREQUENCY_EXCEEDED         = \"VaultPriceFeed: adjustment frequency exceeded\";\n    string public constant VAULTPRICEFEED_INVALID_ADJUSTMENTBPS                 = \"Vaultpricefeed: invalid _adjustmentBps\";\n    string public constant VAULTPRICEFEED_INVALID_SPREADBASISPOINTS             = \"VaultPriceFeed: invalid _spreadBasisPoints\";\n    string public constant VAULTPRICEFEED_INVALID_PRICESAMPLESPACE              = \"VaultPriceFeed: invalid _priceSampleSpace\";\n    string internal constant VAULTPRICEFEED_INVALID_PRICE_FEED                  = \"VaultPriceFeed: invalid price feed\";\n    string internal constant VAULTPRICEFEED_INVALID_PRICE                       = \"VaultPriceFeed: invalid price\";\n    string internal constant CHAINLINK_FEEDS_ARE_NOT_BEING_UPDATED              = \"Chainlink feeds are not being updated\";\n    string internal constant VAULTPRICEFEED_COULD_NOT_FETCH_PRICE               = \"VaultPriceFeed: could not fetch price\";\n\n    /* VaultInternal.sol*/\n    string internal constant VAULT_POOLAMOUNT_EXCEEDED                          = \"Vault: poolAmount exceeded\";\n    string internal constant VAULT_INSUFFICIENT_RESERVE                         = \"Vault: insufficient reserve\";\n    string internal constant VAULT_MAX_SHORTS_EXCEEDED                          = \"Vault: max shorts exceeded\";\n    string internal constant VAULT_POOLAMOUNT_BUFFER                            = \"Vault: poolAmount < buffer\";\n    string internal constant VAULT_INVALID_ERRORCONTROLLER                      = \"Vault: invalid errorController\";\n\n    /* Router.sol */\n    string internal constant ROUTER_INVALID_SENDER                              = \"Router: invalid sender\";\n    string internal constant ROUTER_INVALID_PATH                                = \"Router: invalid _path\";\n    string internal constant ROUTER_MARK_PRICE_HIGHER_THAN_LIMIT                = \"Router: mark price higher than limit\";\n    string internal constant ROUTER_MARK_PRICE_LOWER_THAN_LIMIT                 = \"Router: mark price lower than limit\";\n    string internal constant ROUTER_INVALID_PATH_LENGTH                         = \"Router: invalid _path.length\";\n    string internal constant ROUTER_INSUFFICIENT_AMOUNTOUT                      = \"Router: insufficient amountOut\";\n    string internal constant ROUTER_INVALID_PLUGIN                              = \"Router: invalid plugin\";\n    string internal constant ROUTER_PLUGIN_NOT_APPROVED                         = \"Router: plugin not approved\";\n\n    /* OrderBook.sol*/\n    string internal constant ORDERBOOK_FORBIDDEN                                = \"OrderBook: forbidden\";\n    string internal constant ORDERBOOK_ALREADY_INITIALIZED                      = \"OrderBook: already initialized\";\n    string internal constant ORDERBOOK_INVALID_SENDER                           = \"OrderBook: invalid sender\";\n    string internal constant ORDERBOOK_INVALID_PATH_LENGTH                      = \"OrderBook: invalid _path.length\";\n    string internal constant ORDERBOOK_INVALID_PATH                             = \"OrderBook: invalid _path\";\n    string internal constant ORDERBOOK_INVALID_AMOUNTIN                         = \"OrderBook: invalid _amountIn\";\n    string internal constant ORDERBOOK_INSUFFICIENT_EXECUTION_FEE               = \"OrderBook: insufficient execution fee\";\n    string internal constant ORDERBOOK_ONLY_WETH_COULD_BE_WRAPPED               = \"OrderBook: only weth could be wrapped\";\n    string internal constant ORDERBOOK_INCORRECT_VALUE_TRANSFERRED              = \"OrderBook: incorrect value transferred\";\n    string internal constant ORDERBOOK_INCORRECT_EXECUTION_FEE_TRANSFERRED      = \"OrderBook: incorrect execution fee transferred\";\n    string internal constant ORDERBOOK_NON_EXISTENT_ORDER                       = \"OrderBook: non-existent order\";\n    string internal constant ORDERBOOK_INVALID_PRICE_FOR_EXECUTION              = \"OrderBook: invalid price for execution\";\n    string internal constant ORDERBOOK_INSUFFICIENT_COLLATERAL                  = \"OrderBook: insufficient collateral\";\n    string internal constant ORDERBOOK_INSUFFICIENT_AMOUNTOUT                   = \"OrderBook: insufficient amountOut\";\n\n    /* RewardRouterV2.sol */\n    string internal constant REWARDROUTER_INVALID_AMOUNT                        = \"RewardRouter: invalid _amount\";\n    string internal constant REWARDROUTER_INVALID_MSG_VALUE                     = \"RewardRouter: invalid msg.value\";\n    string internal constant REWARDROUTER_ALREADY_INITIALIZED                   = \"RewardRouter: already initialized\";\n    string internal constant REWARDROUTER_INVALID_MLPAMOUNT                     = \"RewardRouter: invalid _mlpAmount\";\n    string internal constant REWARDROUTER_SENDER_HAS_VESTED_TOKENS              = \"RewardRouter: sender has vested tokens\";\n    string internal constant REWARDROUTER_TRANSFER_NOT_SIGNALLED                = \"RewardRouter: transfer not signalled\";\n    string internal constant REWARDROUTER_STAKEDMOLDTRACKER_AVERAGESTAKEDAMOUNTS_GREATER_0                      = \"RewardRouter: stakedMoldTracker.averageStakedAmounts > 0\";\n    string internal constant REWARDROUTER_STAKEDMOLDTRACKER_CUMULATIVEREWARDS_GREATER_0                         = \"RewardRouter: stakedMoldTracker.cumulativeRewards > 0\";\n    string internal constant REWARDROUTER_BONUSMOLDTRACKER_AVERAGESTAKEDAMOUNTS_GREATER_0                       = \"RewardRouter: bonusMoldTracker.averageStakedAmounts > 0\";\n    string internal constant REWARDROUTER_BONUSMOLDTRACKER_CUMULATIVEREWARDS_GREATER_0                          = \"RewardRouter: bonusMoldTracker.cumulativeRewards > 0\";\n    string internal constant REWARDROUTER_FEEMOLDTRACKER_AVERAGESTAKEDAMOUNTS_GREATER_0                         = \"RewardRouter: feeMoldTracker.averageStakedAmounts > 0\";\n    string internal constant REWARDROUTER_FEEMOLDTRACKER_CUMULATIVEREWARDS_GREATER_0                            = \"RewardRouter: feeMoldTracker.cumulativeRewards > 0\";\n    string internal constant REWARDROUTER_MOLDVESTER_TRANSFERREDAVERAGESTAKEDAMOUNTS_GREATER_0                  = \"RewardRouter: MoldVester.transferredAverageStakedAmounts > 0\";\n    string internal constant REWARDROUTER_MOLDVESTER_TRANSFERREDCUMULATIVEREWARDS_GREATER_0                     = \"RewardRouter: MoldVester.transferredCumulativeRewards > 0\";\n    string internal constant REWARDROUTER_STAKEDMLPTRACKER_AVERAGESTAKEDAMOUNTS_GREATER_0                       = \"RewardRouter: stakedMlpTracker.averageStakedAmounts > 0\";\n    string internal constant REWARDROUTER_STAKEDMLPTRACKER_CUMULATIVEREWARDS_GREATER_0                          = \"RewardRouter: stakedMlpTracker.cumulativeRewards > 0\";\n    string internal constant REWARDROUTER_FEEMLPTRACKER_AVERAGESTAKEDAMOUNTS_GREATER_0                          = \"RewardRouter: feeMlpTracker.averageStakedAmounts > 0\";\n    string internal constant REWARDROUTER_FEEMLPTRACKER_CUMULATIVEREWARDS_GREATER_0                             = \"RewardRouter: feeMlpTracker.cumulativeRewards > 0\";\n    string internal constant REWARDROUTER_MOLDVESTER_BALANCE_GREATER_0          = \"RewardRouter: MoldVester.balance > 0\";\n    string internal constant REWARDROUTER_MLPVESTER_BALANCE_GREATER_0           = \"RewardRouter: MlpVester.balance > 0\";\n\n}\n"
    },
    "contracts/peripherals/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../core/storage/TimelockStorage.sol\";\n\ncontract Timelock is TimelockStorage {\n\n    constructor(address _admin, uint256 _buffer, address _tokenManager, address _mintReceiver, address _mlpManager, uint256 _maxTokenSupply, uint256 _marginFeeBasisPoints, uint256 _maxMarginFeeBasisPoints) public {\n        require(_buffer <= MAX_BUFFER, Errors.TIMELOCK_INVALID_BUFFER);\n        admin = _admin;\n        buffer = _buffer;\n        tokenManager = _tokenManager;\n        mintReceiver = _mintReceiver;\n        mlpManager = _mlpManager;\n        maxTokenSupply = _maxTokenSupply;\n\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        maxMarginFeeBasisPoints = _maxMarginFeeBasisPoints;\n    }\n    \n    function setAdmin(address _admin) external override onlyTokenManager {\n        admin = _admin;\n    }\n\n    function setExternalAdmin(address _target, address _admin) external onlyAdmin {\n        require(_target != address(this), Errors.Timelock_Invalid_Target);\n        IAdmin(_target).setAdmin(_admin);\n    }\n\n    function setContractHandler(address _handler, bool _isActive) external onlyAdmin {\n        isHandler[_handler] = _isActive;\n    }\n\n    function setKeeper(address _keeper, bool _isActive) external onlyAdmin {\n        isKeeper[_keeper] = _isActive;\n    }\n\n    function setBuffer(uint256 _buffer) external onlyAdmin {\n        require(_buffer <= MAX_BUFFER, Errors.Timelock_Invalid_Buffer);\n        require(_buffer > buffer, Errors.Timelock_Buffer_Cannot_Be_Decreased);\n        buffer = _buffer;\n    }\n\n    function setMaxLeverage(address _vault, uint256 _maxLeverage) external onlyAdmin {\n        require(_maxLeverage > MAX_LEVERAGE_VALIDATION, Errors.Timelock_invalid_maxLeverage);\n        IVault(_vault).setMaxLeverage(_maxLeverage);\n    }\n\n    function setFundingRate(address _vault, uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external onlyKeeperAndAbove {\n        // TODO K\n        //        require(_fundingRateFactor < MAX_FUNDING_RATE_FACTOR, Errors.Timelock_invalid_fundingRateFactor);\n        //        require(_stableFundingRateFactor < MAX_FUNDING_RATE_FACTOR, Errors.Timelock_invalid_stableFundingRateFactor);\n        IVault(_vault).setFundingRate(_fundingInterval, _fundingRateFactor, _stableFundingRateFactor);\n    }\n\n    function setShouldToggleIsLeverageEnabled(bool _shouldToggleIsLeverageEnabled) external onlyHandlerAndAbove {\n        shouldToggleIsLeverageEnabled = _shouldToggleIsLeverageEnabled;\n    }\n\n    function setMarginFeeBasisPoints(uint256 _marginFeeBasisPoints, uint256 _maxMarginFeeBasisPoints) external onlyHandlerAndAbove {\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        maxMarginFeeBasisPoints = _maxMarginFeeBasisPoints;\n    }\n\n    function setSwapFees(address _vault, uint256 _taxBasisPoints, uint256 _stableTaxBasisPoints, uint256 _mintBurnFeeBasisPoints, uint256 _swapFeeBasisPoints, uint256 _stableSwapFeeBasisPoints) external onlyKeeperAndAbove {\n        IVault vault = IVault(_vault);\n        vault.setFees(\n            _taxBasisPoints,\n            _stableTaxBasisPoints,\n            _mintBurnFeeBasisPoints,\n            _swapFeeBasisPoints,\n            _stableSwapFeeBasisPoints,\n            maxMarginFeeBasisPoints,\n            vault.liquidationFeeUsd(),\n            vault.minProfitTime(),\n            vault.hasDynamicFees()\n        );\n    }\n\n    function setFees(address _vault, uint256 _taxBasisPoints, uint256 _stableTaxBasisPoints, uint256 _mintBurnFeeBasisPoints, uint256 _swapFeeBasisPoints, uint256 _stableSwapFeeBasisPoints, uint256 _marginFeeBasisPoints, uint256 _liquidationFeeUsd, uint256 _minProfitTime, bool _hasDynamicFees) external onlyKeeperAndAbove {\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        IVault(_vault).setFees(\n            _taxBasisPoints,\n            _stableTaxBasisPoints,\n            _mintBurnFeeBasisPoints,\n            _swapFeeBasisPoints,\n            _stableSwapFeeBasisPoints,\n            maxMarginFeeBasisPoints,\n            _liquidationFeeUsd,\n            _minProfitTime,\n            _hasDynamicFees\n        );\n    }\n\n    function setIsLeverageEnabled(address _vault, bool _isLeverageEnabled) external override onlyHandlerAndAbove {\n        IVault(_vault).setIsLeverageEnabled(_isLeverageEnabled);\n    }\n\n    function setTokenConfig(address _vault, address _token, uint256 _tokenWeight, uint256 _minProfitBps, uint256 _maxUsdmAmount, uint256 _bufferAmount, uint256 _usdmAmount) external onlyKeeperAndAbove {\n        require(_minProfitBps <= 500, Errors.Timelock_invalid_minProfitBps);\n        IVault vault = IVault(_vault);\n        require(vault.whitelistedTokens(_token), Errors.Timelock_token_not_yet_whitelisted);\n        uint256 tokenDecimals = vault.tokenDecimals(_token);\n        bool isStable = vault.stableTokens(_token);\n        bool isShortable = vault.shortableTokens(_token);\n        IVault(_vault).setTokenConfig(\n            _token,\n            tokenDecimals,\n            _tokenWeight,\n            _minProfitBps,\n            _maxUsdmAmount,\n            isStable,\n            isShortable\n        );\n        IVault(_vault).setBufferAmount(_token, _bufferAmount);\n        IVault(_vault).setUsdmAmount(_token, _usdmAmount);\n    }\n\n    function setUsdmAmounts(address _vault, address[] memory _tokens, uint256[] memory _usdmAmounts) external onlyKeeperAndAbove {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IVault(_vault).setUsdmAmount(_tokens[i], _usdmAmounts[i]);\n        }\n    }\n\n    function setMaxGlobalShortSize(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        IVault(_vault).setMaxGlobalShortSize(_token, _amount);\n    }\n\n    function setIsSwapEnabled(address _vault, bool _isSwapEnabled) external onlyKeeperAndAbove {\n        IVault(_vault).setIsSwapEnabled(_isSwapEnabled);\n    }\n\n    function setTier(address _referralStorage, uint256 _tierId, uint256 _totalRebate, uint256 _discountShare) external onlyKeeperAndAbove {\n        IReferralStorage(_referralStorage).setTier(_tierId, _totalRebate, _discountShare);\n    }\n\n    function setReferrerTier(address _referralStorage, address _referrer, uint256 _tierId) external onlyKeeperAndAbove {\n        IReferralStorage(_referralStorage).setReferrerTier(_referrer, _tierId);\n    }\n\n    function setVaultUtils(address _vault, IVaultUtils _vaultUtils) external onlyAdmin {\n        IVault(_vault).setVaultUtils(_vaultUtils);\n    }\n\n    function setMaxGasPrice(address _vault, uint256 _maxGasPrice) external onlyAdmin {\n        require(_maxGasPrice > 5000000000, Errors.TIMELOCK_INVALID_MAXGASPRICE);\n        IVault(_vault).setMaxGasPrice(_maxGasPrice);\n    }\n\n    function setInPrivateLiquidationMode(address _vault, bool _inPrivateLiquidationMode) external onlyAdmin {\n        IVault(_vault).setInPrivateLiquidationMode(_inPrivateLiquidationMode);\n    }\n\n    function setLiquidator(address _vault, address _liquidator, bool _isActive) external onlyAdmin {\n        IVault(_vault).setLiquidator(_liquidator, _isActive);\n    }\n\n    function setInPrivateTransferMode(address _token, bool _inPrivateTransferMode) external onlyAdmin {\n        IBaseToken(_token).setInPrivateTransferMode(_inPrivateTransferMode);\n    }\n\n    function setGov(address _target, address _gov) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _validateAction(action);\n        _clearAction(action);\n        ITimelockTarget(_target).setGov(_gov);\n    }\n\n    function setHandler(address _target, address _handler, bool _isActive) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setHandler\", _target, _handler, _isActive));\n        _validateAction(action);\n        _clearAction(action);\n        IHandlerTarget(_target).setHandler(_handler, _isActive);\n    }\n\n    function setPriceFeed(address _vault, address _priceFeed) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeed\", _vault, _priceFeed));\n        _validateAction(action);\n        _clearAction(action);\n        IVault(_vault).setPriceFeed(_priceFeed);\n    }\n\n    function enableLeverage(address _vault) external override onlyHandlerAndAbove {\n        IVault vault = IVault(_vault);\n        if (shouldToggleIsLeverageEnabled) {\n            vault.setIsLeverageEnabled(true);\n        }\n        vault.setFees(\n            vault.taxBasisPoints(),\n            vault.stableTaxBasisPoints(),\n            vault.mintBurnFeeBasisPoints(),\n            vault.swapFeeBasisPoints(),\n            vault.stableSwapFeeBasisPoints(),\n            marginFeeBasisPoints,\n            vault.liquidationFeeUsd(),\n            vault.minProfitTime(),\n            vault.hasDynamicFees()\n        );\n    }\n\n    function disableLeverage(address _vault) external override onlyHandlerAndAbove {\n        IVault vault = IVault(_vault);\n        if (shouldToggleIsLeverageEnabled) {\n            vault.setIsLeverageEnabled(false);\n        }\n        vault.setFees(\n            vault.taxBasisPoints(),\n            vault.stableTaxBasisPoints(),\n            vault.mintBurnFeeBasisPoints(),\n            vault.swapFeeBasisPoints(),\n            vault.stableSwapFeeBasisPoints(),\n            maxMarginFeeBasisPoints, // marginFeeBasisPoints\n            vault.liquidationFeeUsd(),\n            vault.minProfitTime(),\n            vault.hasDynamicFees()\n        );\n    }\n\n    function updateUsdmSupply(uint256 usdmAmount) external onlyKeeperAndAbove {\n        address usdm = IMlpManager(mlpManager).usdm();\n        uint256 balance = IERC20(usdm).balanceOf(mlpManager);\n        IUSDM(usdm).addVault(address(this));\n        if (usdmAmount > balance) {\n            uint256 mintAmount = usdmAmount.sub(balance);\n            IUSDM(usdm).mint(mlpManager, mintAmount);\n        } else {\n            uint256 burnAmount = balance.sub(usdmAmount);\n            IUSDM(usdm).burn(mlpManager, burnAmount);\n        }\n        IUSDM(usdm).removeVault(address(this));\n    }\n\n    function removeAdmin(address _token, address _account) external onlyAdmin {\n        IYieldToken(_token).removeAdmin(_account);\n    }\n\n    function govSetCodeOwner(address _referralStorage, bytes32 _code, address _newAccount) external onlyKeeperAndAbove {\n        IReferralStorage(_referralStorage).govSetCodeOwner(_code, _newAccount);\n    }\n\n    function withdrawFees(address _vault, address _token, address _receiver) external onlyAdmin {\n        IVault(_vault).withdrawFees(_token, _receiver);\n    }\n\n    function batchWithdrawFees(address _vault, address[] memory _tokens) external onlyKeeperAndAbove {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IVault(_vault).withdrawFees(_tokens[i], admin);\n        }\n    }\n\n    function batchSetBonusRewards(address _vester, address[] memory _accounts, uint256[] memory _amounts) external onlyKeeperAndAbove {\n        require(_accounts.length == _amounts.length, Errors.TIMELOCK_INVALID_LENGTHS);\n        if (!IHandlerTarget(_vester).isHandler(address(this))) {\n            IHandlerTarget(_vester).setHandler(address(this), true);\n        }\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            uint256 amount = _amounts[i];\n            IVester(_vester).setBonusRewards(account, amount);\n        }\n    }\n\n    function transferIn(address _sender, address _token, uint256 _amount) external onlyAdmin {\n        IERC20(_token).transferFrom(_sender, address(this), _amount);\n    }\n\n    function signalApprove(address _token, address _spender, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount));\n        _setPendingAction(action);\n        emit Events.SignalApprove(_token, _spender, _amount, action);\n    }\n\n    function approve(address _token, address _spender, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"approve\", _token, _spender, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    function signalWithdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"withdrawToken\", _target, _token, _receiver, _amount));\n        _setPendingAction(action);\n        emit Events.SignalWithdrawToken(_target, _token, _receiver, _amount, action);\n    }\n\n    function withdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"withdrawToken\", _target, _token, _receiver, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        IBaseToken(_target).withdrawToken(_token, _receiver, _amount);\n    }\n\n    function signalMint(address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"mint\", _token, _receiver, _amount));\n        _setPendingAction(action);\n        emit Events.SignalMint(_token, _receiver, _amount, action);\n    }\n\n    function processMint(address _token, address _receiver, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"mint\", _token, _receiver, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        _mint(_token, _receiver, _amount);\n    }\n\n    function signalSetGov(address _target, address _gov) external override onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setGov\", _target, _gov));\n        _setPendingAction(action);\n        emit Events.SignalSetGov(_target, _gov, action);\n    }\n\n    function signalSetHandler(address _target, address _handler, bool _isActive) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setHandler\", _target, _handler, _isActive));\n        _setPendingAction(action);\n        emit Events.SignalSetHandler(_target, _handler, _isActive, action);\n    }\n\n    function signalSetPriceFeed(address _vault, address _priceFeed) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"setPriceFeed\", _vault, _priceFeed));\n        _setPendingAction(action);\n        emit Events.SignalSetPriceFeed(_vault, _priceFeed, action);\n    }\n\n    function signalRedeemUsdm(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"redeemUsdm\", _vault, _token, _amount));\n        _setPendingAction(action);\n        emit Events.SignalRedeemUsdm(_vault, _token, _amount);\n    }\n\n    function redeemUsdm(address _vault, address _token, uint256 _amount) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\"redeemUsdm\", _vault, _token, _amount));\n        _validateAction(action);\n        _clearAction(action);\n        address usdm = IVault(_vault).usdm();\n        IVault(_vault).setManager(address(this), true);\n        IUSDM(usdm).addVault(address(this));\n        IUSDM(usdm).mint(address(this), _amount);\n        IERC20(usdm).transfer(address(_vault), _amount);\n        IVault(_vault).sellUSDM(_token, mintReceiver);\n        IVault(_vault).setManager(address(this), false);\n        IUSDM(usdm).removeVault(address(this));\n    }\n\n    function signalVaultSetTokenConfig(address _vault, address _token, uint256 _tokenDecimals, uint256 _tokenWeight, uint256 _minProfitBps, uint256 _maxUsdmAmount, bool _isStable, bool _isShortable) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\n                \"vaultSetTokenConfig\",\n                _vault,\n                _token,\n                _tokenDecimals,\n                _tokenWeight,\n                _minProfitBps,\n                _maxUsdmAmount,\n                _isStable,\n                _isShortable\n            ));\n        _setPendingAction(action);\n        emit Events.SignalVaultSetTokenConfig(_vault, _token, _tokenDecimals, _tokenWeight, _minProfitBps, _maxUsdmAmount, _isStable, _isShortable);\n    }\n\n    function vaultSetTokenConfig(address _vault, address _token, uint256 _tokenDecimals, uint256 _tokenWeight, uint256 _minProfitBps, uint256 _maxUsdmAmount, bool _isStable, bool _isShortable) external onlyAdmin {\n        bytes32 action = keccak256(abi.encodePacked(\n                \"vaultSetTokenConfig\",\n                _vault,\n                _token,\n                _tokenDecimals,\n                _tokenWeight,\n                _minProfitBps,\n                _maxUsdmAmount,\n                _isStable,\n                _isShortable\n            ));\n        _validateAction(action);\n        _clearAction(action);\n        IVault(_vault).setTokenConfig(_token, _tokenDecimals, _tokenWeight, _minProfitBps, _maxUsdmAmount, _isStable, _isShortable);\n    }\n\n    function cancelAction(bytes32 _action) external onlyAdmin {\n        _clearAction(_action);\n    }\n\n    function _mint(address _token, address _receiver, uint256 _amount) private {\n        IMintable mintable = IMintable(_token);\n        if (!mintable.isMinter(address(this))) {\n            mintable.setMinter(address(this), true);\n        }\n        mintable.mint(_receiver, _amount);\n        require(IERC20(_token).totalSupply() <= maxTokenSupply, Errors.TIMELOCK_MAXTOKENSUPPLY_EXCEEDED);\n    }\n\n    function _setPendingAction(bytes32 _action) private {\n        require(pendingActions[_action] == 0, Errors.TIMELOCK_ACTION_ALREADY_SIGNALLED);\n        pendingActions[_action] = block.timestamp.add(buffer);\n        emit Events.SignalPendingAction(_action);\n    }\n\n    function _validateAction(bytes32 _action) private view {\n        require(pendingActions[_action] != 0, Errors.TIMELOCK_ACTION_NOT_SIGNALLED);\n        require(pendingActions[_action] < block.timestamp, Errors.TIMELOCK_ACTION_TIME_NOT_YET_PASSED);\n    }\n\n    function _clearAction(bytes32 _action) private {\n        require(pendingActions[_action] != 0, Errors.TIMELOCK_INVALID_ACTION);\n        delete pendingActions[_action];\n        emit Events.ClearAction(_action);\n    }\n}\n"
    },
    "contracts/tokens/USDM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./interfaces/IUSDM.sol\";\nimport \"../libraries/Constants.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"./YieldToken.sol\";\ncontract USDM is YieldToken, IUSDM {\n    mapping (address => bool) public vaults;\n    modifier onlyVault() {\n        require(vaults[msg.sender], Errors.USDM_FORBIDDEN);\n        _;\n    }\n    constructor(address _vault) public YieldToken(Constants.USDM_TOKEN_NAME, Constants.USDM_TOKEN_SYMBOL, 0) {\n        vaults[_vault] = true;\n    }\n    function addVault(address _vault) external override onlyGov {\n        vaults[_vault] = true;\n    }\n    function removeVault(address _vault) external override onlyGov {\n        vaults[_vault] = false;\n    }\n    function mint(address _account, uint256 _amount) external override onlyVault {\n        _mint(_account, _amount);\n    }\n    function burn(address _account, uint256 _amount) external override onlyVault {\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nlibrary Constants {\n    string public constant USDM_TOKEN_NAME = \"USD Mold\";\n    string public constant USDM_TOKEN_SYMBOL = \"USDM\";\n    /* VaultPriceFeed.sol */\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n    uint256 public constant ONE_USD = PRICE_PRECISION;\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public constant MAX_SPREAD_BASIS_POINTS = 50;\n    uint256 public constant MAX_ADJUSTMENT_INTERVAL = 2 hours;\n    uint256 public constant MAX_ADJUSTMENT_BASIS_POINTS = 20;\n    address constant internal FLAG_ARBITRUM_SEQ_OFFLINE = address(bytes20(bytes32(uint256(keccak256(\"chainlink.flags.arbitrum-seq-offline\")) - 1)));\n    /* VaultUtils.sol */\n    uint256 public constant FUNDING_RATE_PRECISION = 1000000;\n\n    /* Vault.sol*/\n    uint256 public constant MIN_LEVERAGE = 10000; // 1x\n    uint256 public constant USDM_DECIMALS = 18;\n    uint256 public constant MAX_FEE_BASIS_POINTS = 500; // 5%\n    uint256 public constant MAX_LIQUIDATION_FEE_USD = 100 * PRICE_PRECISION; // 100 USD\n    uint256 public constant MIN_FUNDING_RATE_INTERVAL = 1 hours;\n    uint256 public constant MAX_FUNDING_RATE_FACTOR = 10000; // 1%\n\n    /* OrderBook.sol */\n    uint256 public constant USDM_PRECISION = 1e18;\n\n    /* MLP.sol */\n    uint256 public constant MLP_PRECISION = 10 ** 18;\n    uint256 public constant MAX_COOLDOWN_DURATION = 48 hours;\n}\n"
    },
    "contracts/tokens/YieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../core/storage/YieldTokenStorage.sol\";\n\ncontract YieldToken is YieldTokenStorage {\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) public {\n        name = _name;\n        symbol = _symbol;\n        gov = msg.sender;\n        admins[msg.sender] = true;\n        _mint(msg.sender, _initialSupply);\n    }\n    function addAdmin(address _account) external onlyGov {\n        admins[_account] = true;\n    }\n    function removeAdmin(address _account) external override onlyGov {\n        admins[_account] = false;\n    }\n    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n    function addNonStakingAccount(address _account) external onlyAdmin {\n        require(!nonStakingAccounts[_account], \"YieldToken: _account already marked\");\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = true;\n        nonStakingSupply = nonStakingSupply.add(balances[_account]);\n    }\n    function removeNonStakingAccount(address _account) external onlyAdmin {\n        require(nonStakingAccounts[_account], \"YieldToken: _account not marked\");\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = false;\n        nonStakingSupply = nonStakingSupply.sub(balances[_account]);\n    }\n    function recoverClaim(address _account, address _receiver) external onlyAdmin {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(_account, _receiver);\n        }\n    }\n    function claim(address _receiver) external {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(msg.sender, _receiver);\n        }\n    }\n    /* settings*/\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n    function setInfo(string memory _name, string memory _symbol) external onlyGov {\n        name = _name;\n        symbol = _symbol;\n    }\n    function setYieldTrackers(address[] memory _yieldTrackers) external onlyGov {\n        yieldTrackers = _yieldTrackers;\n    }\n    function setInWhitelistMode(bool _inWhitelistMode) external onlyGov {\n        inWhitelistMode = _inWhitelistMode;\n    }\n    function setWhitelistedHandler(address _handler, bool _isWhitelisted) external onlyGov {\n        whitelistedHandlers[_handler] = _isWhitelisted;\n    }\n    /* views */\n    function totalStaked() external view override returns (uint256) {\n        return totalSupply.sub(nonStakingSupply);\n    }\n    function balanceOf(address _account) external view override returns (uint256) {\n        return balances[_account];\n    }\n    function stakedBalance(address _account) external view override returns (uint256) {\n        if (nonStakingAccounts[_account]) {\n            return 0;\n        }\n        return balances[_account];\n    }\n    function transfer(address _recipient, uint256 _amount) external override returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n    function allowance(address _owner, address _spender) external view override returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n    function approve(address _spender, uint256 _amount) external override returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external override returns (bool) {\n        uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, \"YieldToken: transfer amount exceeds allowance\");\n        _approve(_sender, msg.sender, nextAllowance);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n    /*internal */\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"YieldToken: mint to the zero address\");\n        _updateRewards(_account);\n        totalSupply = totalSupply.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n        emit Transfer(address(0), _account, _amount);\n    }\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"YieldToken: burn from the zero address\");\n        _updateRewards(_account);\n        balances[_account] = balances[_account].sub(_amount, \"YieldToken: burn amount exceeds balance\");\n        totalSupply = totalSupply.sub(_amount);\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n        emit Transfer(_account, address(0), _amount);\n    }\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_sender != address(0), \"YieldToken: transfer from the zero address\");\n        require(_recipient != address(0), \"YieldToken: transfer to the zero address\");\n        if (inWhitelistMode) {\n            require(whitelistedHandlers[msg.sender], \"YieldToken: msg.sender not whitelisted\");\n        }\n        _updateRewards(_sender);\n        _updateRewards(_recipient);\n        balances[_sender] = balances[_sender].sub(_amount, \"YieldToken: transfer amount exceeds balance\");\n        balances[_recipient] = balances[_recipient].add(_amount);\n        if (nonStakingAccounts[_sender]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n        if (nonStakingAccounts[_recipient]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n        emit Transfer(_sender, _recipient,_amount);\n    }\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_owner != address(0), \"YieldToken: approve from the zero address\");\n        require(_spender != address(0), \"YieldToken: approve to the zero address\");\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n    function _updateRewards(address _account) private {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).updateRewards(_account);\n        }\n    }\n}\n"
    },
    "contracts/core/storage/YieldTokenStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../tokens/interfaces/IYieldTracker.sol\";\nimport \"../../tokens/interfaces/IYieldToken.sol\";\n\nabstract contract YieldTokenStorage is IERC20, IYieldToken {\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 public nonStakingSupply;\n    bool public inWhitelistMode;\n    address public gov;\n    address[] public yieldTrackers;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowances;\n    mapping (address => bool) public nonStakingAccounts;\n    mapping (address => bool) public admins;\n    mapping (address => bool) public whitelistedHandlers;\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    modifier onlyGov() {\n        require(msg.sender == gov, \"YieldToken: forbidden\");\n        _;\n    }\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"YieldToken: forbidden\");\n        _;\n    }\n}\n"
    },
    "contracts/libraries/token/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IERC20.sol\";\nimport \"../math/SafeMath.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/libraries/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/tokens/BaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/token/SafeERC20.sol\";\n\nimport \"./interfaces/IYieldTracker.sol\";\nimport \"./interfaces/IBaseToken.sol\";\n\ncontract BaseToken is IERC20, IBaseToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    uint256 public override totalSupply;\n    uint256 public nonStakingSupply;\n\n    address public gov;\n\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowances;\n\n    address[] public yieldTrackers;\n    mapping (address => bool) public nonStakingAccounts;\n    mapping (address => bool) public admins;\n\n    bool public inPrivateTransferMode;\n    mapping (address => bool) public isHandler;\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"BaseToken: forbidden\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"BaseToken: forbidden\");\n        _;\n    }\n\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) public {\n        name = _name;\n        symbol = _symbol;\n        gov = msg.sender;\n        _mint(msg.sender, _initialSupply);\n    }\n\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n\n    function setInfo(string memory _name, string memory _symbol) external onlyGov {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function setYieldTrackers(address[] memory _yieldTrackers) external onlyGov {\n        yieldTrackers = _yieldTrackers;\n    }\n\n    function addAdmin(address _account) external onlyGov {\n        admins[_account] = true;\n    }\n\n    function removeAdmin(address _account) external override onlyGov {\n        admins[_account] = false;\n    }\n\n    // to help users who accidentally send their tokens to this contract\n    function withdrawToken(address _token, address _account, uint256 _amount) external override onlyGov {\n        IERC20(_token).safeTransfer(_account, _amount);\n    }\n\n    function setInPrivateTransferMode(bool _inPrivateTransferMode) external override onlyGov {\n        inPrivateTransferMode = _inPrivateTransferMode;\n    }\n\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        isHandler[_handler] = _isActive;\n    }\n\n    function addNonStakingAccount(address _account) external onlyAdmin {\n        require(!nonStakingAccounts[_account], \"BaseToken: _account already marked\");\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = true;\n        nonStakingSupply = nonStakingSupply.add(balances[_account]);\n    }\n\n    function removeNonStakingAccount(address _account) external onlyAdmin {\n        require(nonStakingAccounts[_account], \"BaseToken: _account not marked\");\n        _updateRewards(_account);\n        nonStakingAccounts[_account] = false;\n        nonStakingSupply = nonStakingSupply.sub(balances[_account]);\n    }\n\n    function recoverClaim(address _account, address _receiver) external onlyAdmin {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(_account, _receiver);\n        }\n    }\n\n    function claim(address _receiver) external {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).claim(msg.sender, _receiver);\n        }\n    }\n\n    function totalStaked() external view override returns (uint256) {\n        return totalSupply.sub(nonStakingSupply);\n    }\n\n    function balanceOf(address _account) external view override returns (uint256) {\n        return balances[_account];\n    }\n\n    function stakedBalance(address _account) external view override returns (uint256) {\n        if (nonStakingAccounts[_account]) {\n            return 0;\n        }\n        return balances[_account];\n    }\n\n    function transfer(address _recipient, uint256 _amount) external override returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view override returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _amount) external override returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external override returns (bool) {\n        if (isHandler[msg.sender]) {\n            _transfer(_sender, _recipient, _amount);\n            return true;\n        }\n        uint256 nextAllowance = allowances[_sender][msg.sender].sub(_amount, \"BaseToken: transfer amount exceeds allowance\");\n        _approve(_sender, msg.sender, nextAllowance);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"BaseToken: mint to the zero address\");\n\n        _updateRewards(_account);\n\n        totalSupply = totalSupply.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"BaseToken: burn from the zero address\");\n\n        _updateRewards(_account);\n\n        balances[_account] = balances[_account].sub(_amount, \"BaseToken: burn amount exceeds balance\");\n        totalSupply = totalSupply.sub(_amount);\n\n        if (nonStakingAccounts[_account]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_sender != address(0), \"BaseToken: transfer from the zero address\");\n        require(_recipient != address(0), \"BaseToken: transfer to the zero address\");\n\n        if (inPrivateTransferMode) {\n            require(isHandler[msg.sender], \"BaseToken: msg.sender not whitelisted\");\n        }\n\n        _updateRewards(_sender);\n        _updateRewards(_recipient);\n\n        balances[_sender] = balances[_sender].sub(_amount, \"BaseToken: transfer amount exceeds balance\");\n        balances[_recipient] = balances[_recipient].add(_amount);\n\n        if (nonStakingAccounts[_sender]) {\n            nonStakingSupply = nonStakingSupply.sub(_amount);\n        }\n        if (nonStakingAccounts[_recipient]) {\n            nonStakingSupply = nonStakingSupply.add(_amount);\n        }\n\n        emit Transfer(_sender, _recipient,_amount);\n    }\n\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_owner != address(0), \"BaseToken: approve from the zero address\");\n        require(_spender != address(0), \"BaseToken: approve to the zero address\");\n\n        allowances[_owner][_spender] = _amount;\n\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _updateRewards(address _account) private {\n        for (uint256 i = 0; i < yieldTrackers.length; i++) {\n            address yieldTracker = yieldTrackers[i];\n            IYieldTracker(yieldTracker).updateRewards(_account);\n        }\n    }\n}\n"
    },
    "contracts/core/storage/VaultAggregators.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/DataTypes.sol\";\nimport \"../../libraries/Constants.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/utils/ReentrancyGuard.sol\";\nimport \"../interfaces/IVaultUtils.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IVaultPriceFeed.sol\";\nimport \"../../tokens/interfaces/IUSDM.sol\";\nimport \"hardhat/console.sol\";\n\nabstract contract VaultAggregators is IVault, ReentrancyGuard {\n}\n"
    },
    "contracts/libraries/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nlibrary DataTypes {\n    struct IncreaseOrder {\n        address account;\n        address purchaseToken;\n        uint256 purchaseTokenAmount;\n        address collateralToken;\n        address indexToken;\n        uint256 sizeDelta;\n        bool isLong;\n        uint256 triggerPrice;\n        bool triggerAboveThreshold;\n        uint256 executionFee;\n    }\n    struct DecreaseOrder {\n        address account;\n        address collateralToken;\n        uint256 collateralDelta;\n        address indexToken;\n        uint256 sizeDelta;\n        bool isLong;\n        uint256 triggerPrice;\n        bool triggerAboveThreshold;\n        uint256 executionFee;\n    }\n    struct SwapOrder {\n        address account;\n        address[] path;\n        uint256 amountIn;\n        uint256 minOut;\n        uint256 triggerRatio;\n        bool triggerAboveThreshold;\n        bool shouldUnwrap;\n        uint256 executionFee;\n    }\n\n    /* Vault.sol */\n    struct Position {\n        uint256 size;\n        uint256 collateral;\n        uint256 averagePrice; // col average price\n        uint256 entryFundingRate;\n        uint256 reserveAmount;\n        int256 realisedPnl;\n        uint256 lastIncreasedTime;\n    }\n}\n"
    },
    "contracts/libraries/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/core/MlpManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./settings/MlpManagerSettings.sol\";\nimport \"hardhat/console.sol\";\n\ncontract MlpManager is MlpManagerSettings {\n    constructor(address _vault, address _usdm, address _mlp, address _shortsTracker, uint256 _cooldownDuration) public {\n        gov = msg.sender;\n        vault = IVault(_vault);\n        usdm = _usdm;\n        mlp = _mlp;\n        shortsTracker = IShortsTracker(_shortsTracker);\n        cooldownDuration = _cooldownDuration;\n    }\n    function addLiquidity(address _token, uint256 _amount, uint256 _minUsdm, uint256 _minMlp) external override nonReentrant returns (uint256) {\n        if (inPrivateMode) {revert(Errors.MLPMANAGER_ACTION_NOT_ENABLED);}\n        return _addLiquidity(msg.sender, msg.sender, _token, _amount, _minUsdm, _minMlp);\n    }\n\n    function addLiquidityForAccount(address _fundingAccount, address _account, address _token, uint256 _amount, uint256 _minUsdm, uint256 _minMlp) external override nonReentrant returns (uint256) {\n        _validateHandler();\n        return _addLiquidity(_fundingAccount, _account, _token, _amount, _minUsdm, _minMlp);\n    }\n\n    function removeLiquidity(address _tokenOut, uint256 _mlpAmount, uint256 _minOut, address _receiver) external override nonReentrant returns (uint256) {\n        if (inPrivateMode) {revert(Errors.MLPMANAGER_ACTION_NOT_ENABLED);}\n        return _removeLiquidity(msg.sender, _tokenOut, _mlpAmount, _minOut, _receiver);\n    }\n\n    function removeLiquidityForAccount(address _account, address _tokenOut, uint256 _mlpAmount, uint256 _minOut, address _receiver) external override nonReentrant returns (uint256) {\n        _validateHandler();\n        return _removeLiquidity(_account, _tokenOut, _mlpAmount, _minOut, _receiver);\n    }\n\n    function _addLiquidity(address _fundingAccount, address _account, address _token, uint256 _amount, uint256 _minUsdm, uint256 _minMlp) internal returns (uint256) {\n        require(_amount > 0, Errors.MLPMANAGER_INVALID_AMOUNT);\n        uint256 aumInUsdm = getAumInUsdm(true);\n        uint256 mlpSupply = IERC20(mlp).totalSupply();\n        IERC20(_token).safeTransferFrom(_fundingAccount, address(vault), _amount);\n        uint256 usdmAmount = vault.buyUSDM(_token, address(this));\n        require(usdmAmount >= _minUsdm, Errors.MLPMANAGER_INSUFFICIENT_USDM_OUTPUT);\n        uint256 mintAmount = aumInUsdm == 0 || mlpSupply == 0 ? usdmAmount : usdmAmount.mul(mlpSupply).div(aumInUsdm);\n        console.log(\"## mintAmount:\", mintAmount);\n        console.log(\"## _minMlp:\", _minMlp);\n        require(mintAmount >= _minMlp, Errors.MLPMANAGER_INSUFFICIENT_MLP_OUTPUT);\n        IMintable(mlp).mint(_account, mintAmount);\n        lastAddedAt[_account] = block.timestamp;\n        emit Events.AddLiquidity(_account, _token, _amount, aumInUsdm, mlpSupply, usdmAmount, mintAmount);\n        return mintAmount;\n    }\n\n    function _removeLiquidity(address _account, address _tokenOut, uint256 _mlpAmount, uint256 _minOut, address _receiver) internal returns (uint256) {\n        require(_mlpAmount > 0, Errors.MLPMANAGER_INVALID_MLPAMOUNT);\n        require(lastAddedAt[_account].add(cooldownDuration) <= block.timestamp, Errors.MLPMANAGER_COOLDOWN_DURATION_NOT_YET_PASSED);\n        uint256 aumInUsdm = getAumInUsdm(false);\n        uint256 mlpSupply = IERC20(mlp).totalSupply();\n        uint256 usdmAmount = _mlpAmount.mul(aumInUsdm).div(mlpSupply);\n        uint256 usdmBalance = IERC20(usdm).balanceOf(address(this));\n        if (usdmAmount > usdmBalance) {\n            IUSDM(usdm).mint(address(this), usdmAmount.sub(usdmBalance));\n        }\n        IMintable(mlp).burn(_account, _mlpAmount);\n        IERC20(usdm).transfer(address(vault), usdmAmount);\n        uint256 amountOut = vault.sellUSDM(_tokenOut, _receiver);\n        require(amountOut >= _minOut, Errors.MLPMANAGER_INSUFFICIENT_OUTPUT);\n        emit Events.RemoveLiquidity(_account, _tokenOut, _mlpAmount, aumInUsdm, mlpSupply, usdmAmount, amountOut);\n        return amountOut;\n    }\n\n    function _validateHandler() internal view {\n        require(isHandler[msg.sender], Errors.MLPMANAGER_FORBIDDEN);\n    }\n\n    function getAumInUsdm(bool maximise) public override view returns (uint256) {\n        uint256 aum = getAum(maximise);\n        return aum.mul(10 ** Constants.USDM_DECIMALS).div(Constants.PRICE_PRECISION);\n    }\n\n    function getAum(bool maximise) public view returns (uint256) {\n        uint256 length = vault.allWhitelistedTokensLength();\n        uint256 aum = aumAddition;\n        uint256 shortProfits = 0;\n        IVault _vault = vault;\n        for (uint256 i = 0; i < length; i++) {\n            address token = vault.allWhitelistedTokens(i);\n            bool isWhitelisted = vault.whitelistedTokens(token);\n            if (!isWhitelisted) {\n                continue;\n            }\n            uint256 price = maximise ? _vault.getMaxPrice(token) : _vault.getMinPrice(token);\n            uint256 poolAmount = _vault.poolAmounts(token);\n            uint256 decimals = _vault.tokenDecimals(token);\n            if (_vault.stableTokens(token)) {\n                aum = aum.add(poolAmount.mul(price).div(10 ** decimals));\n            } else {\n                uint256 size = _vault.globalShortSizes(token);\n                if (size > 0) {\n                    (uint256 delta, bool hasProfit) = getGlobalShortDelta(token, price, size);\n                    if (!hasProfit) {\n                        aum = aum.add(delta);\n                    } else {\n                        shortProfits = shortProfits.add(delta);\n                    }\n                }\n                aum = aum.add(_vault.guaranteedUsd(token));\n                uint256 reservedAmount = _vault.reservedAmounts(token);\n                aum = aum.add(poolAmount.sub(reservedAmount).mul(price).div(10 ** decimals));\n            }\n        }\n        aum = shortProfits > aum ? 0 : aum.sub(shortProfits);\n        return aumDeduction > aum ? 0 : aum.sub(aumDeduction);\n    }\n\n    function getGlobalShortDelta(address _token, uint256 _price, uint256 _size) public view returns (uint256, bool) {\n        uint256 averagePrice = getGlobalShortAveragePrice(_token);\n        uint256 priceDelta = averagePrice > _price ? averagePrice.sub(_price) : _price.sub(averagePrice);\n        uint256 delta = _size.mul(priceDelta).div(averagePrice);\n        return (delta, averagePrice > _price);\n    }\n\n    function getGlobalShortAveragePrice(address _token) public view returns (uint256) {\n        IShortsTracker _shortsTracker = shortsTracker;\n        if (address(_shortsTracker) == address(0) || !_shortsTracker.isGlobalShortDataReady()) {\n            return vault.globalShortAveragePrices(_token);\n        }\n        uint256 _shortsTrackerAveragePriceWeight = shortsTrackerAveragePriceWeight;\n        if (_shortsTrackerAveragePriceWeight == 0) {\n            return vault.globalShortAveragePrices(_token);\n        } else if (_shortsTrackerAveragePriceWeight == Constants.BASIS_POINTS_DIVISOR) {\n            return _shortsTracker.globalShortAveragePrices(_token);\n        }\n        uint256 vaultAveragePrice = vault.globalShortAveragePrices(_token);\n        uint256 shortsTrackerAveragePrice = _shortsTracker.globalShortAveragePrices(_token);\n        return vaultAveragePrice.mul(Constants.BASIS_POINTS_DIVISOR.sub(_shortsTrackerAveragePriceWeight)).add(shortsTrackerAveragePrice.mul(_shortsTrackerAveragePriceWeight)).div(Constants.BASIS_POINTS_DIVISOR);\n    }\n}\n"
    },
    "contracts/core/settings/MlpManagerSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../storage/MlpManagerStorage.sol\";\nabstract contract MlpManagerSettings is MlpManagerStorage {\n    function setInPrivateMode(bool _inPrivateMode) external onlyGov {\n        inPrivateMode = _inPrivateMode;\n    }\n    function setShortsTrackerAveragePriceWeight(uint256 _shortsTrackerAveragePriceWeight) external onlyGov {\n        require(shortsTrackerAveragePriceWeight <= Constants.BASIS_POINTS_DIVISOR, Errors.MLPMANAGER_INVALID_WEIGHT);\n        shortsTrackerAveragePriceWeight = _shortsTrackerAveragePriceWeight;\n    }\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        isHandler[_handler] = _isActive;\n    }\n    function setCooldownDuration(uint256 _cooldownDuration) external onlyGov {\n        require(_cooldownDuration <= Constants.MAX_COOLDOWN_DURATION, Errors.MLPMANAGER_INVALID_COOLDOWNDURATION);\n        cooldownDuration = _cooldownDuration;\n    }\n    function setAumAdjustment(uint256 _aumAddition, uint256 _aumDeduction) external onlyGov {\n        aumAddition = _aumAddition;\n        aumDeduction = _aumDeduction;\n    }\n\n    //    function getPrice(bool _maximise) external view returns (uint256) {\n    //        uint256 aum = getAum(_maximise);\n    //        uint256 supply = IERC20(mlp).totalSupply();\n    //        return aum.mul(MLP_PRECISION).div(supply);\n    //    }\n    //    function getAums() public view returns (uint256[] memory) {\n    //        uint256[] memory amounts = new uint256[](2);\n    //        amounts[0] = getAum(true);\n    //        amounts[1] = getAum(false);\n    //        return amounts;\n    //    }\n}\n"
    },
    "contracts/core/storage/MlpManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./MlpManagerAggregators.sol\";\nabstract contract MlpManagerStorage is MlpManagerAggregators {\n    /* constructor */\n    IVault public vault;\n    address public override usdm;\n    address public mlp;\n    IShortsTracker public shortsTracker;\n    /* settings */\n    bool public inPrivateMode;\n    uint256 public shortsTrackerAveragePriceWeight;\n    mapping (address => bool) public isHandler;\n    uint256 public override cooldownDuration;\n    uint256 public aumAddition;\n    uint256 public aumDeduction;\n    /* misc */\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    mapping (address => uint256) public override lastAddedAt; /* account address => timestamp*/\n}\n"
    },
    "contracts/core/storage/MlpManagerAggregators.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/Constants.sol\";\nimport \"../../libraries/utils/ReentrancyGuard.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IShortsTracker.sol\";\nimport \"../interfaces/IMlpManager.sol\";\nimport \"../../tokens/interfaces/IUSDM.sol\";\nimport \"../../tokens/interfaces/IMintable.sol\";\nimport \"../../access/Governable.sol\";\nabstract contract MlpManagerAggregators is IMlpManager, ReentrancyGuard, Governable {\n}\n"
    },
    "contracts/core/interfaces/IShortsTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IShortsTracker {\n    function isGlobalShortDataReady() external view returns (bool);\n    function globalShortAveragePrices(address _token) external view returns (uint256);\n    function getNextGlobalShortData(address _account, address _collateralToken, address _indexToken, uint256 _nextPrice, uint256 _sizeDelta, bool _isIncrease) external view returns (uint256, uint256);\n    function updateGlobalShortData(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _sizeDelta, uint256 _markPrice, bool _isIncrease) external;\n}\n"
    },
    "contracts/tokens/MintableBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./BaseToken.sol\";\nimport \"./interfaces/IMintable.sol\";\n\ncontract MintableBaseToken is BaseToken, IMintable {\n\n    mapping (address => bool) public override isMinter;\n\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) public BaseToken(_name, _symbol, _initialSupply) {\n    }\n\n    modifier onlyMinter() {\n        require(isMinter[msg.sender], \"MintableBaseToken: forbidden\");\n        _;\n    }\n\n    function setMinter(address _minter, bool _isActive) external override onlyGov {\n        isMinter[_minter] = _isActive;\n    }\n\n    function mint(address _account, uint256 _amount) external override onlyMinter {\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override onlyMinter {\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/gmx/MLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../tokens/MintableBaseToken.sol\";\n\ncontract MLP is MintableBaseToken {\n    constructor() public MintableBaseToken(\"MOLD LP\", \"MLP\", 0) {\n    }\n\n    function id() external pure returns (string memory _name) {\n        return \"MLP\";\n    }\n}\n"
    },
    "contracts/gmx/GMX.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../tokens/MintableBaseToken.sol\";\n\ncontract GMX is MintableBaseToken {\n    constructor() public MintableBaseToken(\"GMX\", \"GMX\", 0) {\n    }\n\n    function id() external pure returns (string memory _name) {\n        return \"GMX\";\n    }\n}\n"
    },
    "contracts/core/storage/RewardRouterV2Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/utils/ReentrancyGuard.sol\";\nimport \"../../libraries/utils/Address.sol\";\nimport \"../../staking/interfaces/IRewardTracker.sol\";\nimport \"../../staking/interfaces/IVester.sol\";\nimport \"../../tokens/interfaces/IMintable.sol\";\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../interfaces/IMlpManager.sol\";\nimport \"../../access/Governable.sol\";\n\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\n\nabstract contract RewardRouterV2Aggregator is ReentrancyGuard, Governable {\n\n}\n"
    },
    "contracts/staking/interfaces/IRewardTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IRewardTracker {\n    function depositBalances(address _account, address _depositToken) external view returns (uint256);\n    function stakedAmounts(address _account) external view returns (uint256);\n    function updateRewards() external;\n    function stake(address _depositToken, uint256 _amount) external;\n    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;\n    function unstake(address _depositToken, uint256 _amount) external;\n    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;\n    function tokensPerInterval() external view returns (uint256);\n    function claim(address _receiver) external returns (uint256);\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n    function claimable(address _account) external view returns (uint256);\n    function averageStakedAmounts(address _account) external view returns (uint256);\n    function cumulativeRewards(address _account) external view returns (uint256);\n}\n"
    },
    "contracts/tokens/interfaces/IWETH.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}"
    },
    "contracts/core/storage/ShortsTrackerAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IShortsTracker.sol\";\nimport \"../../access/Governable.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nabstract contract ShortsTrackerAggregator is IShortsTracker, Governable {\n}\n"
    },
    "contracts/mock/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../libraries/token/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract Token is IERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    address private _owner;\n    uint256 public interval;\n    uint256 public faucetTotal;\n    uint256 public faucetAmount;\n    uint256 public giveawayTotal;\n    bool public faucetEnabled = true;\n    bool public openMint = true;\n\n    mapping(address => uint256) accountLastTime;\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory _n) public {\n        _name = _n;\n        _symbol = _n;\n        _decimals = 18;\n        interval = 1 hours;\n        faucetTotal = 100000000 ether;\n        faucetAmount = 10000 ether;\n    }\n\n    function mint(address account, uint256 amount) public {\n        if (!openMint)\n            require(_owner == _msgSender(), \"Caller is not the owner\");\n        _mint(account, amount);\n    }\n\n    function faucet() external {\n        require(faucetEnabled, \"Faucet is not enabled now.\");\n        require(faucetTotal >= giveawayTotal + faucetAmount, \"Faucet total is running out now.\");\n        require(block.timestamp - accountLastTime[msg.sender] > interval, \"Faucet interval is not expired.\");\n\n        giveawayTotal += faucetAmount;\n        accountLastTime[msg.sender] = block.timestamp;\n        _mint(msg.sender, faucetAmount);\n    }\n\n    function withdrawToken(address token, address account, uint256 amount) public {\n        IERC20(token).transfer(account, amount);\n    }\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public {\n        require(_balances[msg.sender] >= amount, \"Token: insufficient balance\");\n        _burn(msg.sender, amount);\n        msg.sender.transfer(amount);\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function setFaucetAmount(uint256 _faucetAmount) external onlyOwner {\n        faucetAmount = _faucetAmount;\n    }\n\n    function setFaucetEnabled(bool _faucetEnabled) external onlyOwner {\n        faucetEnabled = _faucetEnabled;\n    }\n\n    function setInterval(uint256 _inverval) external onlyOwner {\n        interval = _inverval;\n    }\n\n    function setFaucetTotal(uint256 _faucetTotal) external {\n        faucetTotal = _faucetTotal;\n    }\n\n    function setOpenMint(bool open) external {\n        openMint = open;\n    }\n}\n"
    },
    "contracts/core/storage/VaultUtilsStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/DataTypes.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/Constants.sol\";\nimport \"../interfaces/IShortsTracker.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IVaultUtils.sol\";\nimport \"../../access/Governable.sol\";\nabstract contract VaultUtilsStorage  is IVaultUtils,Governable{\n    IVault public vault;\n    using SafeMath for uint256;\n}\n"
    },
    "contracts/core/VaultUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./storage/VaultUtilsStorage.sol\";\ncontract VaultUtils is VaultUtilsStorage {\n    constructor(IVault _vault) public {\n        vault = _vault;\n    }\n    function updateCumulativeFundingRate(address,address) public override returns (bool) {\n        return true;\n    }\n    function validateIncreasePosition(address,address,address,uint256,bool) external override view {\n    }\n    function validateDecreasePosition(address,address,address,uint256,uint256,bool,address) external override view {\n    }\n    function validateLiquidation(address _account, address _collateralToken, address _indexToken, bool _isLong, bool _raise) public view override returns (uint256, uint256) {\n        DataTypes.Position memory position = getPosition(_account, _collateralToken, _indexToken, _isLong);\n        IVault _vault = vault;\n        (bool hasProfit, uint256 delta) = _vault.getDelta(_indexToken, position.size, position.averagePrice, _isLong, position.lastIncreasedTime);\n        uint256 marginFees = getFundingFee(_account, _collateralToken, _indexToken, _isLong, position.size, position.entryFundingRate);\n        marginFees = marginFees.add(getPositionFee(_account, _collateralToken, _indexToken, _isLong, position.size));\n        if (!hasProfit && position.collateral < delta) {\n            if (_raise) { revert(Errors.VAULT_LOSSES_EXCEED_COLLATERAL); }\n            return (1, marginFees);\n        }\n        uint256 remainingCollateral = position.collateral;\n        if (!hasProfit) {\n            remainingCollateral = position.collateral.sub(delta);\n        }\n        if (remainingCollateral < marginFees) {\n            if (_raise) { revert(Errors.VAULT_FEES_EXCEED_COLLATERAL); }\n            return (1, remainingCollateral);\n        }\n        if (remainingCollateral < marginFees.add(_vault.liquidationFeeUsd())) {\n            if (_raise) { revert(Errors.VAULT_LIQUIDATION_FEES_EXCEED_COLLATERAL); }\n            return (1, marginFees);\n        }\n        if (remainingCollateral.mul(_vault.maxLeverage()) < position.size.mul(Constants.BASIS_POINTS_DIVISOR)) {\n            if (_raise) { revert(Errors.VAULT_MAXLEVERAGE_EXCEEDED); }\n            return (2, marginFees);\n        }\n        return (0, marginFees);\n    }\n    function getEntryFundingRate(address _collateralToken,address, bool) public override view returns (uint256) {\n        return vault.cumulativeFundingRates(_collateralToken);\n    }\n    function getPositionFee(address,address,address,bool,uint256 _sizeDelta) public override view returns (uint256) {\n        if (_sizeDelta == 0) { return 0; }\n        uint256 afterFeeUsd = _sizeDelta.mul(Constants.BASIS_POINTS_DIVISOR.sub(vault.marginFeeBasisPoints())).div(Constants.BASIS_POINTS_DIVISOR);\n        return _sizeDelta.sub(afterFeeUsd);\n    }\n    function getFundingFee(address, address _collateralToken, address,bool,uint256 _size, uint256 _entryFundingRate) public override view returns (uint256) {\n        if (_size == 0) { return 0; }\n        uint256 fundingRate = vault.cumulativeFundingRates(_collateralToken).sub(_entryFundingRate);\n        if (fundingRate == 0) { return 0; }\n        return _size.mul(fundingRate).div(Constants.FUNDING_RATE_PRECISION);\n    }\n    function getBuyUsdmFeeBasisPoints(address _token, uint256 _usdmAmount) public override view returns (uint256) {\n        return getFeeBasisPoints(_token, _usdmAmount, vault.mintBurnFeeBasisPoints(), vault.taxBasisPoints(), true);\n    }\n    function getSellUsdmFeeBasisPoints(address _token, uint256 _usdmAmount) public override view returns (uint256) {\n        return getFeeBasisPoints(_token, _usdmAmount, vault.mintBurnFeeBasisPoints(), vault.taxBasisPoints(), false);\n    }\n    function getSwapFeeBasisPoints(address _tokenIn, address _tokenOut, uint256 _usdmAmount) public override view returns (uint256) {\n        bool isStableSwap = vault.stableTokens(_tokenIn) && vault.stableTokens(_tokenOut);\n        uint256 baseBps = isStableSwap ? vault.stableSwapFeeBasisPoints() : vault.swapFeeBasisPoints();\n        uint256 taxBps = isStableSwap ? vault.stableTaxBasisPoints() : vault.taxBasisPoints();\n        uint256 feesBasisPoints0 = getFeeBasisPoints(_tokenIn, _usdmAmount, baseBps, taxBps, true);\n        uint256 feesBasisPoints1 = getFeeBasisPoints(_tokenOut, _usdmAmount, baseBps, taxBps, false);\n        return feesBasisPoints0 > feesBasisPoints1 ? feesBasisPoints0 : feesBasisPoints1;\n    }\n    function getFeeBasisPoints(address _token, uint256 _usdmDelta, uint256 _feeBasisPoints, uint256 _taxBasisPoints, bool _increment) public override view returns (uint256) {\n        if (!vault.hasDynamicFees()) { return _feeBasisPoints; }\n        uint256 initialAmount = vault.usdmAmounts(_token);\n        uint256 nextAmount = initialAmount.add(_usdmDelta);\n        if (!_increment) {\n            nextAmount = _usdmDelta > initialAmount ? 0 : initialAmount.sub(_usdmDelta);\n        }\n        uint256 targetAmount = vault.getTargetUsdmAmount(_token);\n        if (targetAmount == 0) { return _feeBasisPoints; }\n        uint256 initialDiff = initialAmount > targetAmount ? initialAmount.sub(targetAmount) : targetAmount.sub(initialAmount);\n        uint256 nextDiff = nextAmount > targetAmount ? nextAmount.sub(targetAmount) : targetAmount.sub(nextAmount);\n        if (nextDiff < initialDiff) {\n            uint256 rebateBps = _taxBasisPoints.mul(initialDiff).div(targetAmount);\n            return rebateBps > _feeBasisPoints ? 0 : _feeBasisPoints.sub(rebateBps);\n        }\n        uint256 averageDiff = initialDiff.add(nextDiff).div(2);\n        if (averageDiff > targetAmount) {\n            averageDiff = targetAmount;\n        }\n        uint256 taxBps = _taxBasisPoints.mul(averageDiff).div(targetAmount);\n        return _feeBasisPoints.add(taxBps);\n    }\n    function getPosition(address _account, address _collateralToken, address _indexToken, bool _isLong) internal view returns (DataTypes.Position memory) {\n        IVault _vault = vault;\n        DataTypes.Position memory position;\n        {\n            (uint256 size, uint256 collateral, uint256 averagePrice, uint256 entryFundingRate, , , , uint256 lastIncreasedTime) = _vault.getPosition(_account, _collateralToken, _indexToken, _isLong);\n            position.size = size;\n            position.collateral = collateral;\n            position.averagePrice = averagePrice;\n            position.entryFundingRate = entryFundingRate;\n            position.lastIncreasedTime = lastIncreasedTime;\n        }\n        return position;\n    }\n}\n"
    },
    "contracts/peripherals/VaultReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../core/interfaces/IVault.sol\";\nimport \"../core/interfaces/IVaultPriceFeed.sol\";\nimport \"../core/interfaces/IBasePositionManager.sol\";\ncontract VaultReader {\n    function getVaultTokenInfoV3(address _vault, address _positionManager, address _weth, uint256 _usdmAmount, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 14;\n        IVault vault = IVault(_vault);\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(vault.priceFeed());\n        IBasePositionManager positionManager = IBasePositionManager(_positionManager);\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.usdmAmounts(token);\n            amounts[i * propsLength + 3] = vault.getRedemptionAmount(token, _usdmAmount);\n            amounts[i * propsLength + 4] = vault.tokenWeights(token);\n            amounts[i * propsLength + 5] = vault.bufferAmounts(token);\n            amounts[i * propsLength + 6] = vault.maxUsdmAmounts(token);\n            amounts[i * propsLength + 7] = vault.globalShortSizes(token);\n            amounts[i * propsLength + 8] = positionManager.maxGlobalShortSizes(token);\n            amounts[i * propsLength + 9] = vault.getMinPrice(token);\n            amounts[i * propsLength + 10] = vault.getMaxPrice(token);\n            amounts[i * propsLength + 11] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 12] = priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 13] = priceFeed.getPrimaryPrice(token, true);\n        }\n        return amounts;\n    }\n    function getVaultTokenInfoV4(address _vault, address _positionManager, address _weth, uint256 _usdmAmount, address[] memory _tokens) public view returns (uint256[] memory) {\n        uint256 propsLength = 15;\n        IVault vault = IVault(_vault);\n        IVaultPriceFeed priceFeed = IVaultPriceFeed(vault.priceFeed());\n        IBasePositionManager positionManager = IBasePositionManager(_positionManager);\n        uint256[] memory amounts = new uint256[](_tokens.length * propsLength);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            if (token == address(0)) {\n                token = _weth;\n            }\n            amounts[i * propsLength] = vault.poolAmounts(token);\n            amounts[i * propsLength + 1] = vault.reservedAmounts(token);\n            amounts[i * propsLength + 2] = vault.usdmAmounts(token);\n            amounts[i * propsLength + 3] = vault.getRedemptionAmount(token, _usdmAmount);\n            amounts[i * propsLength + 4] = vault.tokenWeights(token);\n            amounts[i * propsLength + 5] = vault.bufferAmounts(token);\n            amounts[i * propsLength + 6] = vault.maxUsdmAmounts(token);\n            amounts[i * propsLength + 7] = vault.globalShortSizes(token);\n            amounts[i * propsLength + 8] = positionManager.maxGlobalShortSizes(token);\n            amounts[i * propsLength + 9] = positionManager.maxGlobalLongSizes(token);\n            amounts[i * propsLength + 10] = vault.getMinPrice(token);\n            amounts[i * propsLength + 11] = vault.getMaxPrice(token);\n            amounts[i * propsLength + 12] = vault.guaranteedUsd(token);\n            amounts[i * propsLength + 13] = priceFeed.getPrimaryPrice(token, false);\n            amounts[i * propsLength + 14] = priceFeed.getPrimaryPrice(token, true);\n        }\n\n        return amounts;\n    }\n}\n"
    },
    "contracts/core/interfaces/IBasePositionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IBasePositionManager {\n    function maxGlobalLongSizes(address _token) external view returns (uint256);\n    function maxGlobalShortSizes(address _token) external view returns (uint256);\n}\n"
    },
    "contracts/core/storage/BasePositionManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/utils/Address.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../interfaces/IBasePositionManager.sol\";\n\nabstract contract BasePositionManagerStorage is IBasePositionManager {\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    uint256 public depositFee;\n    uint256 public increasePositionBufferBps = 100;\n    address public admin;\n    address public vault;\n    address public shortsTracker;\n    address public router;\n    address public weth;\n    address public referralStorage;\n    mapping(address => uint256) public override maxGlobalLongSizes; /* token => uint*/\n    mapping(address => uint256) public override maxGlobalShortSizes; /* token => uint*/\n    mapping(address => uint256) public feeReserves; /* token=> uint*/\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n    \n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"BasePositionManager: forbidden\");\n        _;\n    }\n    \n    receive() external payable {\n        require(msg.sender == weth, Errors.BASEPOSITIONMANAGER_INVALID_SENDER);\n    }\n}\n"
    },
    "contracts/core/settings/PositionManagerSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../storage/PositionManagerStorage.sol\";\nimport \"../storage/BasePositionManagerStorage.sol\";\nimport \"./PositionManagerAggregator.sol\";\nabstract contract PositionManagerSettings is\n    PositionManagerStorage,\n    BasePositionManagerStorage,\n    PositionManagerAggregator\n{\n    function setOrderKeeper(address _account, bool _isActive) external onlyAdmin {\n        isOrderKeeper[_account] = _isActive;\n        emit Events.SetOrderKeeper(_account, _isActive);\n    }\n    function setLiquidator(address _account, bool _isActive) external onlyAdmin {\n        isLiquidator[_account] = _isActive;\n        emit Events.SetLiquidator(_account, _isActive);\n    }\n    function setPartner(address _account, bool _isActive) external onlyAdmin {\n        isPartner[_account] = _isActive;\n        emit Events.SetPartner(_account, _isActive);\n    }\n    function setOpened(bool _opened) external onlyAdmin {\n        opened = _opened;\n        emit Events.SetOpened(_opened);\n    }\n    function setShouldValidateIncreaseOrder(bool _shouldValidateIncreaseOrder) external onlyAdmin {\n        shouldValidateIncreaseOrder = _shouldValidateIncreaseOrder;\n        emit Events.SetShouldValidateIncreaseOrder(_shouldValidateIncreaseOrder);\n    }\n}\n"
    },
    "contracts/core/storage/PositionManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/Errors.sol\";\nabstract contract PositionManagerStorage {\n    bool public opened;\n    bool public shouldValidateIncreaseOrder = true;\n    address public orderBook;\n    mapping (address => bool) public isOrderKeeper; /* address => bool*/\n    mapping (address => bool) public isPartner; /* address => bool*/\n    mapping (address => bool) public isLiquidator; /* address => bool*/\n    modifier onlyOrderKeeper() {\n        require(isOrderKeeper[msg.sender], Errors.POSITIONMANAGER_FORBIDDEN);\n        _;\n    }\n    modifier onlyPartnersOrOpened() {\n        require(isPartner[msg.sender] || opened, Errors.POSITIONMANAGER_FORBIDDEN);\n        _;\n    }\n    modifier onlyLiquidator() {\n        require(isLiquidator[msg.sender], Errors.POSITIONMANAGER_FORBIDDEN);\n        _;\n    }\n}\n"
    },
    "contracts/core/settings/PositionManagerAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IOrderBook.sol\";\nimport \"../../peripherals/interfaces/ITimelock.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\n\nabstract contract PositionManagerAggregator{\n\n}\n"
    },
    "contracts/core/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IRouter {\n    function addPlugin(address _plugin) external;\n    function pluginTransfer(address _token, address _account, address _receiver, uint256 _amount) external;\n    function pluginIncreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external;\n    function pluginDecreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) external returns (uint256);\n    function swap(address[] memory _path, uint256 _amountIn, uint256 _minOut, address _receiver) external;\n}\n"
    },
    "contracts/core/interfaces/IOrderBook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IOrderBook {\n//\tfunction getSwapOrder(address _account, uint256 _orderIndex) external view returns (address path0, address path1, address path2, uint256 amountIn, uint256 minOut, uint256 triggerRatio, bool triggerAboveThreshold, bool shouldUnwrap, uint256 executionFee);\n//  function getIncreaseOrder(address _account, uint256 _orderIndex) external view returns (address purchaseToken, uint256 purchaseTokenAmount, address collateralToken, address indexToken, uint256 sizeDelta, bool isLong, uint256 triggerPrice, bool triggerAboveThreshold, uint256 executionFee);\n//  function getDecreaseOrder(address _account, uint256 _orderIndex) external view returns (address collateralToken, uint256 collateralDelta, address indexToken, uint256 sizeDelta, bool isLong, uint256 triggerPrice, bool triggerAboveThreshold, uint256 executionFee);\n//    function executeSwapOrder(address, uint256, address payable) external;\n//    function executeDecreaseOrder(address, uint256, address payable) external;\n//    function executeIncreaseOrder(address, uint256, address payable) external;\n}\n"
    },
    "contracts/core/settings/BasePositionManagerAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IShortsTracker.sol\";\nimport \"../interfaces/IOrderBook.sol\";\nimport \"../../peripherals/interfaces/ITimelock.sol\";\nimport \"../../referrals/interfaces/IReferralStorage.sol\";\nimport \"../../libraries/utils/ReentrancyGuard.sol\";\nimport \"../../access/Governable.sol\";\nabstract contract BasePositionManagerAggregator is Governable, ReentrancyGuard{\n}\n"
    },
    "contracts/core/storage/OrderBookAggregators.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/utils/Address.sol\";\nimport \"../../libraries/utils/ReentrancyGuard.sol\";\nimport \"../../libraries/DataTypes.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/Constants.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IOrderBook.sol\";\nabstract contract OrderBookAggregators is ReentrancyGuard, IOrderBook {\n}\n"
    },
    "contracts/core/storage/RouterStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/token/IERC20.sol\";\nimport \"../../libraries/token/SafeERC20.sol\";\nimport \"../../libraries/utils/Address.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/Events.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IRouter.sol\";\nabstract contract RouterStorage is IRouter {\n    address public gov;\n    address public weth;\n    address public usdm;\n    address public vault;\n    mapping (address => bool) public plugins;\n    mapping (address => mapping (address => bool)) public approvedPlugins;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n    modifier onlyGov() {\n        require(msg.sender == gov, Errors.ROUTER_FORBIDDEN);\n        _;\n    }\n}\n"
    },
    "contracts/core/settings/RouterSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../storage/RouterStorage.sol\";\nabstract contract RouterSettings is RouterStorage {\n    function _increasePosition(address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong, uint256 _price) internal {\n        if (_isLong) {\n            require(IVault(vault).getMaxPrice(_indexToken) <= _price, Errors.ROUTER_MARK_PRICE_HIGHER_THAN_LIMIT);\n        } else {\n            require(IVault(vault).getMinPrice(_indexToken) >= _price, Errors.ROUTER_MARK_PRICE_LOWER_THAN_LIMIT);\n        }\n        IVault(vault).increasePosition(_sender(), _collateralToken, _indexToken, _sizeDelta, _isLong);\n    }\n    function _decreasePosition(address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver, uint256 _price) internal returns (uint256) {\n        if (_isLong) {\n            require(IVault(vault).getMinPrice(_indexToken) >= _price, Errors.ROUTER_MARK_PRICE_LOWER_THAN_LIMIT);\n        } else {\n            require(IVault(vault).getMaxPrice(_indexToken) <= _price, Errors.ROUTER_MARK_PRICE_HIGHER_THAN_LIMIT);\n        }\n        return IVault(vault).decreasePosition(_sender(), _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n    }\n    function _transferETHToVault() internal {\n        IWETH(weth).deposit{value: msg.value}();\n        IERC20(weth).safeTransfer(vault, msg.value);\n    }\n    function _transferOutETH(uint256 _amountOut, address payable _receiver) internal {\n        IWETH(weth).withdraw(_amountOut);\n        _receiver.sendValue(_amountOut);\n    }\n    function _swap(address[] memory _path, uint256 _minOut, address _receiver) internal returns (uint256) {\n        if (_path.length == 2) {\n            return _vaultSwap(_path[0], _path[1], _minOut, _receiver);\n        }\n        if (_path.length == 3) {\n            uint256 midOut = _vaultSwap(_path[0], _path[1], 0, address(this));\n            IERC20(_path[1]).safeTransfer(vault, midOut);\n            return _vaultSwap(_path[1], _path[2], _minOut, _receiver);\n        }\n        revert(Errors.ROUTER_INVALID_PATH_LENGTH);\n    }\n    function _vaultSwap(address _tokenIn, address _tokenOut, uint256 _minOut, address _receiver) internal returns (uint256) {\n        uint256 amountOut;\n        if (_tokenOut == usdm) {\n            amountOut = IVault(vault).buyUSDM(_tokenIn, _receiver);\n        } else if (_tokenIn == usdm) {\n            amountOut = IVault(vault).sellUSDM(_tokenOut, _receiver);\n        } else {\n            amountOut = IVault(vault).swap(_tokenIn, _tokenOut, _receiver);\n        }\n        require(amountOut >= _minOut, Errors.ROUTER_INSUFFICIENT_AMOUNTOUT);\n        return amountOut;\n    }\n    function _sender() internal view returns (address) {\n        return msg.sender;\n    }\n    function _validatePlugin(address _account) internal view {\n        require(plugins[msg.sender], Errors.ROUTER_INVALID_PLUGIN);\n        require(approvedPlugins[_account][msg.sender], Errors.ROUTER_PLUGIN_NOT_APPROVED);\n    }\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n}\n"
    },
    "contracts/core/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./settings/RouterSettings.sol\";\n\ncontract Router is RouterSettings {\n    \n    constructor(address _vault, address _usdm, address _weth) public {\n        vault = _vault;\n        usdm = _usdm;\n        weth = _weth;\n        gov = msg.sender;\n    }\n    \n    receive() external payable {\n        require(msg.sender == weth, Errors.ROUTER_INVALID_SENDER);\n    }\n\n    function addPlugin(address _plugin) external override onlyGov {\n        plugins[_plugin] = true;\n    }\n\n    function removePlugin(address _plugin) external onlyGov {\n        plugins[_plugin] = false;\n    }\n\n    function approvePlugin(address _plugin) external {\n        approvedPlugins[msg.sender][_plugin] = true;\n    }\n\n    function denyPlugin(address _plugin) external {\n        approvedPlugins[msg.sender][_plugin] = false;\n    }\n\n    function pluginTransfer(address _token, address _account, address _receiver, uint256 _amount) external override {\n        _validatePlugin(_account);\n        IERC20(_token).safeTransferFrom(_account, _receiver, _amount);\n    }\n\n    function pluginIncreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external override {\n        _validatePlugin(_account);\n        IVault(vault).increasePosition(_account, _collateralToken, _indexToken, _sizeDelta, _isLong);\n    }\n\n    function pluginDecreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) external override returns (uint256) {\n        _validatePlugin(_account);\n        return IVault(vault).decreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n    }\n\n    function directPoolDeposit(address _token, uint256 _amount) external {\n        IERC20(_token).safeTransferFrom(_sender(), vault, _amount);\n        IVault(vault).directPoolDeposit(_token);\n    }\n\n    function increasePosition(address[] memory _path, address _indexToken, uint256 _amountIn, uint256 _minOut, uint256 _sizeDelta, bool _isLong, uint256 _price) external {\n        if (_amountIn > 0) {\n            IERC20(_path[0]).safeTransferFrom(_sender(), vault, _amountIn);\n        }\n        if (_path.length > 1 && _amountIn > 0) {\n            uint256 amountOut = _swap(_path, _minOut, address(this));\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, amountOut);\n        }\n        _increasePosition(_path[_path.length - 1], _indexToken, _sizeDelta, _isLong, _price);\n    }\n\n    function increasePositionETH(address[] memory _path, address _indexToken, uint256 _minOut, uint256 _sizeDelta, bool _isLong, uint256 _price) external payable {\n        require(_path[0] == weth, Errors.ROUTER_INVALID_PATH);\n        if (msg.value > 0) {\n            _transferETHToVault();\n        }\n        if (_path.length > 1 && msg.value > 0) {\n            uint256 amountOut = _swap(_path, _minOut, address(this));\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, amountOut);\n        }\n        _increasePosition(_path[_path.length - 1], _indexToken, _sizeDelta, _isLong, _price);\n    }\n\n    function decreasePosition(address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver, uint256 _price) external {\n        _decreasePosition(_collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver, _price);\n    }\n\n    function decreasePositionETH(address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address payable _receiver, uint256 _price) external {\n        uint256 amountOut = _decreasePosition(_collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, address(this), _price);\n        _transferOutETH(amountOut, _receiver);\n    }\n\n    function decreasePositionAndSwap(address[] memory _path, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver, uint256 _price, uint256 _minOut) external {\n        uint256 amount = _decreasePosition(_path[0], _indexToken, _collateralDelta, _sizeDelta, _isLong, address(this), _price);\n        IERC20(_path[0]).safeTransfer(vault, amount);\n        _swap(_path, _minOut, _receiver);\n    }\n\n    function decreasePositionAndSwapETH(address[] memory _path, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address payable _receiver, uint256 _price, uint256 _minOut) external {\n        require(_path[_path.length - 1] == weth, Errors.ROUTER_INVALID_PATH);\n        uint256 amount = _decreasePosition(_path[0], _indexToken, _collateralDelta, _sizeDelta, _isLong, address(this), _price);\n        IERC20(_path[0]).safeTransfer(vault, amount);\n        uint256 amountOut = _swap(_path, _minOut, address(this));\n        _transferOutETH(amountOut, _receiver);\n    }\n\n    function swap(address[] memory _path, uint256 _amountIn, uint256 _minOut, address _receiver) public override {\n        IERC20(_path[0]).safeTransferFrom(_sender(), vault, _amountIn);\n        uint256 amountOut = _swap(_path, _minOut, _receiver);\n        emit Events.Swap(msg.sender, _path[0], _path[_path.length - 1], _amountIn, amountOut);\n    }\n\n    function swapETHToTokens(address[] memory _path, uint256 _minOut, address _receiver) external payable {\n        require(_path[0] == weth, Errors.ROUTER_INVALID_PATH);\n        _transferETHToVault();\n        uint256 amountOut = _swap(_path, _minOut, _receiver);\n        emit Events.Swap(msg.sender, _path[0], _path[_path.length - 1], msg.value, amountOut);\n    }\n\n    function swapTokensToETH(address[] memory _path, uint256 _amountIn, uint256 _minOut, address payable _receiver) external {\n        require(_path[_path.length - 1] == weth, Errors.ROUTER_INVALID_PATH);\n        IERC20(_path[0]).safeTransferFrom(_sender(), vault, _amountIn);\n        uint256 amountOut = _swap(_path, _minOut, address(this));\n        _transferOutETH(amountOut, _receiver);\n        emit Events.Swap(msg.sender, _path[0], _path[_path.length - 1], _amountIn, amountOut);\n    }\n}\n"
    },
    "contracts/core/storage/VaultPriceFeedStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../../oracle/interfaces/IPriceFeed.sol\";\nimport \"../../oracle/interfaces/ISecondaryPriceFeed.sol\";\nimport \"../../oracle/interfaces/IChainlinkFlags.sol\";\nimport \"../../amm/interfaces/IPancakePair.sol\";\nimport \"../interfaces/IVaultPriceFeed.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/Constants.sol\";\nabstract contract VaultPriceFeedStorage is IVaultPriceFeed  {\n    uint256 public spreadThresholdBasisPoints = 30;\n    uint256 public priceSampleSpace = 3;\n    uint256 public maxStrictPriceDeviation = 0;\n    bool public isAmmEnabled = true;\n    bool public isSecondaryPriceEnabled = true;\n    bool public useV2Pricing = false;\n    bool public favorPrimaryPrice = false;\n    address public gov;\n    address public chainlinkFlags;\n    address public secondaryPriceFeed;\n    address public btc;\n    address public eth;\n    address public bnb;\n    address public bnbBusd;\n    address public ethBnb;\n    address public btcBnb;\n    mapping (address => address) public priceFeeds;\n    mapping (address => uint256) public priceDecimals;\n    mapping (address => uint256) public spreadBasisPoints;\n    mapping (address => bool) public strictStableTokens;\n    mapping (address => uint256) public override adjustmentBasisPoints;\n    mapping (address => bool) public override isAdjustmentAdditive;\n    mapping (address => uint256) public lastAdjustmentTimings;\n    using SafeMath for uint256;\n    modifier onlyGov() {\n        require(msg.sender == gov, Errors.VAULTPRICEFEED_FORBIDDEN);\n        _;\n    }\n}\n"
    },
    "contracts/oracle/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IPriceFeed {\n    function description() external view returns (string memory);\n    function aggregator() external view returns (address);\n    function latestAnswer() external view returns (int256);\n    function latestRound() external view returns (uint80);\n    function getRoundData(uint80 roundId) external view returns (uint80, int256, uint256, uint256, uint80);\n}\n"
    },
    "contracts/oracle/interfaces/ISecondaryPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface ISecondaryPriceFeed {\n    function getPrice(address _token, uint256 _referencePrice, bool _maximise) external view returns (uint256);\n}\n"
    },
    "contracts/oracle/interfaces/IChainlinkFlags.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ninterface IChainlinkFlags {\n  function getFlag(address) external view returns (bool);\n}\n"
    },
    "contracts/amm/interfaces/IPancakePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IPancakePair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n"
    },
    "contracts/oracle/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"../libraries/Errors.sol\";\ncontract PriceFeed is IPriceFeed {\n    int256 public answer;\n    uint80 public roundId;\n    string public override description = \"PriceFeed\";\n    address public override aggregator;\n    uint256 public decimals;\n    address public gov;\n    mapping (uint80 => int256) public answers;\n    mapping (address => bool) public isAdmin;\n\n    constructor() public {\n        gov = msg.sender;\n        isAdmin[msg.sender] = true;\n    }\n    function setAdmin(address _account, bool _isAdmin) public {\n        require(msg.sender == gov, Errors.PriceFeed_forbidden);\n        isAdmin[_account] = _isAdmin;\n    }\n    function latestAnswer() public override view returns (int256) {\n        return answer;\n    }\n    function latestRound() public override view returns (uint80) {\n        return roundId;\n    }\n    function setLatestAnswer(int256 _answer) public {\n        require(isAdmin[msg.sender], Errors.PriceFeed_forbidden);\n        roundId = roundId + 1;\n        answer = _answer;\n        answers[roundId] = _answer;\n    }\n    function getRoundData(uint80 _roundId) public override view returns (uint80, int256, uint256, uint256, uint80) {\n        return (_roundId, answers[_roundId], 0, 0, 0);\n    }\n}\n"
    },
    "contracts/core/settings/VaultPriceFeedSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../storage/VaultPriceFeedStorage.sol\";\nabstract contract VaultPriceFeedSettings is VaultPriceFeedStorage {\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n    function setChainlinkFlags(address _chainlinkFlags) external onlyGov {\n        chainlinkFlags = _chainlinkFlags;\n    }\n    function setAdjustment(address _token, bool _isAdditive, uint256 _adjustmentBps) external override onlyGov {\n        require(\n            lastAdjustmentTimings[_token].add(Constants.MAX_ADJUSTMENT_INTERVAL) < block.timestamp,\n            Errors.VAULTPRICEFEED_ADJUSTMENT_FREQUENCY_EXCEEDED\n        );\n        require(_adjustmentBps <= Constants.MAX_ADJUSTMENT_BASIS_POINTS, Errors.VAULTPRICEFEED_INVALID_ADJUSTMENTBPS);\n        isAdjustmentAdditive[_token] = _isAdditive;\n        adjustmentBasisPoints[_token] = _adjustmentBps;\n        lastAdjustmentTimings[_token] = block.timestamp;\n    }\n    function setUseV2Pricing(bool _useV2Pricing) external override onlyGov {\n        useV2Pricing = _useV2Pricing;\n    }\n    function setIsAmmEnabled(bool _isEnabled) external override onlyGov {\n        isAmmEnabled = _isEnabled;\n    }\n\n    function setIsSecondaryPriceEnabled(bool _isEnabled) external override onlyGov {\n        isSecondaryPriceEnabled = _isEnabled;\n    }\n    function setSecondaryPriceFeed(address _secondaryPriceFeed) external onlyGov {\n        secondaryPriceFeed = _secondaryPriceFeed;\n    }\n    function setTokens(address _btc, address _eth, address _bnb) external onlyGov {\n        btc = _btc;\n        eth = _eth;\n        bnb = _bnb;\n    }\n    function setPairs(address _bnbBusd, address _ethBnb, address _btcBnb) external onlyGov {\n        bnbBusd = _bnbBusd;\n        ethBnb = _ethBnb;\n        btcBnb = _btcBnb;\n    }\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints) external override onlyGov {\n        require(_spreadBasisPoints <= Constants.MAX_SPREAD_BASIS_POINTS, Errors.VAULTPRICEFEED_INVALID_SPREADBASISPOINTS);\n        spreadBasisPoints[_token] = _spreadBasisPoints;\n    }\n\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints) external override onlyGov {\n        spreadThresholdBasisPoints = _spreadThresholdBasisPoints;\n    }\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external override onlyGov {\n        favorPrimaryPrice = _favorPrimaryPrice;\n    }\n    function setPriceSampleSpace(uint256 _priceSampleSpace) external override onlyGov {\n        require(_priceSampleSpace > 0, Errors.VAULTPRICEFEED_INVALID_PRICESAMPLESPACE);\n        priceSampleSpace = _priceSampleSpace;\n    }\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation) external override onlyGov {\n        maxStrictPriceDeviation = _maxStrictPriceDeviation;\n    }\n    function setTokenConfig(address _token, address _priceFeed, uint256 _priceDecimals, bool _isStrictStable) external override onlyGov {\n        priceFeeds[_token] = _priceFeed;\n        priceDecimals[_token] = _priceDecimals;\n        strictStableTokens[_token] = _isStrictStable;\n    }\n}\n"
    },
    "contracts/core/VaultPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./settings/VaultPriceFeedSettings.sol\";\ncontract VaultPriceFeed is VaultPriceFeedSettings {\n    constructor() public {\n        gov = msg.sender;\n    }\n    function getPrice(\n        address _token,\n        bool _maximise,\n        bool _includeAmmPrice, bool) public override view returns (uint256) {\n        uint256 price = useV2Pricing ? getPriceV2(_token, _maximise, _includeAmmPrice) : getPriceV1(_token, _maximise, _includeAmmPrice);\n        uint256 adjustmentBps = adjustmentBasisPoints[_token];\n        if (adjustmentBps > 0) {\n            bool isAdditive = isAdjustmentAdditive[_token];\n            if (isAdditive) {\n                price = price.mul(Constants.BASIS_POINTS_DIVISOR.add(adjustmentBps)).div(Constants.BASIS_POINTS_DIVISOR);\n            } else {\n                price = price.mul(Constants.BASIS_POINTS_DIVISOR.sub(adjustmentBps)).div(Constants.BASIS_POINTS_DIVISOR);\n            }\n        }\n        return price;\n    }\n    function getPriceV1(\n        address _token,\n        bool _maximise,\n        bool _includeAmmPrice) public view returns (uint256) {\n        uint256 price = getPrimaryPrice(_token, _maximise);\n        if (_includeAmmPrice && isAmmEnabled) {\n            uint256 ammPrice = getAmmPrice(_token);\n            if (ammPrice > 0) {\n                if (_maximise && ammPrice > price) {\n                    price = ammPrice;\n                }\n                if (!_maximise && ammPrice < price) {\n                    price = ammPrice;\n                }\n            }\n        }\n        if (isSecondaryPriceEnabled) {\n            price = getSecondaryPrice(_token, price, _maximise);\n        }\n        if (strictStableTokens[_token]) {\n            uint256 delta = price > Constants.ONE_USD ? price.sub(Constants.ONE_USD) : Constants.ONE_USD.sub(price);\n            if (delta <= maxStrictPriceDeviation) {\n                return Constants.ONE_USD;\n            }\n            if (_maximise && price > Constants.ONE_USD) {\n                return price;\n            }\n            if (!_maximise && price < Constants.ONE_USD) {\n                return price;\n            }\n            return Constants.ONE_USD;\n        }\n        uint256 _spreadBasisPoints = spreadBasisPoints[_token];\n        if (_maximise) {\n            return price.mul(Constants.BASIS_POINTS_DIVISOR.add(_spreadBasisPoints)).div(Constants.BASIS_POINTS_DIVISOR);\n        }\n        return price.mul(Constants.BASIS_POINTS_DIVISOR.sub(_spreadBasisPoints)).div(Constants.BASIS_POINTS_DIVISOR);\n    }\n    function getPriceV2(\n        address _token,\n        bool _maximise,\n        bool _includeAmmPrice) public view returns (uint256) {\n        uint256 price = getPrimaryPrice(_token, _maximise);\n        if (_includeAmmPrice && isAmmEnabled) {\n            price = getAmmPriceV2(_token, _maximise, price);\n        }\n        if (isSecondaryPriceEnabled) {\n            price = getSecondaryPrice(_token, price, _maximise);\n        }\n        if (strictStableTokens[_token]) {\n            uint256 delta = price > Constants.ONE_USD ? price.sub(Constants.ONE_USD) : Constants.ONE_USD.sub(price);\n            if (delta <= maxStrictPriceDeviation) {\n                return Constants.ONE_USD;\n            }\n            if (_maximise && price > Constants.ONE_USD) {\n                return price;\n            }\n            if (!_maximise && price < Constants.ONE_USD) {\n                return price;\n            }\n            return Constants.ONE_USD;\n        }\n        uint256 _spreadBasisPoints = spreadBasisPoints[_token];\n        if (_maximise) {\n            return price.mul(Constants.BASIS_POINTS_DIVISOR.add(_spreadBasisPoints)).div(Constants.BASIS_POINTS_DIVISOR);\n        }\n        return price.mul(Constants.BASIS_POINTS_DIVISOR.sub(_spreadBasisPoints)).div(Constants.BASIS_POINTS_DIVISOR);\n    }\n    function getAmmPriceV2(\n        address _token,\n        bool _maximise,\n        uint256 _primaryPrice) public view returns (uint256) {\n        uint256 ammPrice = getAmmPrice(_token);\n        if (ammPrice == 0) {\n            return _primaryPrice;\n        }\n        uint256 diff = ammPrice > _primaryPrice ? ammPrice.sub(_primaryPrice) : _primaryPrice.sub(ammPrice);\n        if (diff.mul(Constants.BASIS_POINTS_DIVISOR) < _primaryPrice.mul(spreadThresholdBasisPoints)) {\n            if (favorPrimaryPrice) {\n                return _primaryPrice;\n            }\n            return ammPrice;\n        }\n        if (_maximise && ammPrice > _primaryPrice) {\n            return ammPrice;\n        }\n        if (!_maximise && ammPrice < _primaryPrice) {\n            return ammPrice;\n        }\n        return _primaryPrice;\n    }\n    function getLatestPrimaryPrice(address _token) public override view returns (uint256) {\n        address priceFeedAddress = priceFeeds[_token];\n        require(priceFeedAddress != address(0), Errors.VAULTPRICEFEED_INVALID_PRICE_FEED);\n        IPriceFeed priceFeed = IPriceFeed(priceFeedAddress);\n        int256 price = priceFeed.latestAnswer();\n        require(price > 0, Errors.VAULTPRICEFEED_INVALID_PRICE);\n        return uint256(price);\n    }\n    function getPrimaryPrice(\n        address _token,\n        bool _maximise) public override view returns (uint256) {\n        address priceFeedAddress = priceFeeds[_token];\n        require(priceFeedAddress != address(0), Errors.VAULTPRICEFEED_INVALID_PRICE_FEED);\n        if (chainlinkFlags != address(0)) {\n            bool isRaised = IChainlinkFlags(chainlinkFlags).getFlag(Constants.FLAG_ARBITRUM_SEQ_OFFLINE);\n            if (isRaised) {\n                revert(Errors.CHAINLINK_FEEDS_ARE_NOT_BEING_UPDATED);\n            }\n        }\n        IPriceFeed priceFeed = IPriceFeed(priceFeedAddress);\n        uint256 price = 0;\n        uint80 roundId = priceFeed.latestRound();\n        for (uint80 i = 0; i < priceSampleSpace; i++) {\n            if (roundId <= i) { break; }\n            uint256 p;\n            if (i == 0) {\n                int256 _p = priceFeed.latestAnswer();\n                require(_p > 0, Errors.VAULTPRICEFEED_INVALID_PRICE);\n                p = uint256(_p);\n            } else {\n                (, int256 _p, , ,) = priceFeed.getRoundData(roundId - i);\n                require(_p > 0, Errors.VAULTPRICEFEED_INVALID_PRICE);\n                p = uint256(_p);\n            }\n            if (price == 0) {\n                price = p;\n                continue;\n            }\n            if (_maximise && p > price) {\n                price = p;\n                continue;\n            }\n            if (!_maximise && p < price) {\n                price = p;\n            }\n        }\n        require(price > 0, Errors.VAULTPRICEFEED_COULD_NOT_FETCH_PRICE);\n        uint256 _priceDecimals = priceDecimals[_token];\n        return price.mul(Constants.PRICE_PRECISION).div(10 ** _priceDecimals);\n    }\n    function getSecondaryPrice(\n        address _token,\n        uint256 _referencePrice,\n        bool _maximise) public view returns (uint256) {\n        if (secondaryPriceFeed == address(0)) { return _referencePrice; }\n        return ISecondaryPriceFeed(secondaryPriceFeed).getPrice(_token, _referencePrice, _maximise);\n    }\n    function getAmmPrice(address _token) public override view returns (uint256) {\n        if (_token == bnb) {\n            return getPairPrice(bnbBusd, true);\n        }\n        if (_token == eth) {\n            uint256 price0 = getPairPrice(bnbBusd, true);\n            uint256 price1 = getPairPrice(ethBnb, true);\n            return price0.mul(price1).div(Constants.PRICE_PRECISION);\n        }\n        if (_token == btc) {\n            uint256 price0 = getPairPrice(bnbBusd, true);\n            uint256 price1 = getPairPrice(btcBnb, true);\n            return price0.mul(price1).div(Constants.PRICE_PRECISION);\n        }\n        return 0;\n    }\n    function getPairPrice(address _pair, bool _divByReserve0) public view returns (uint256) {\n        (uint256 reserve0, uint256 reserve1, ) = IPancakePair(_pair).getReserves();\n        if (_divByReserve0) {\n            if (reserve0 == 0) { return 0; }\n            return reserve1.mul(Constants.PRICE_PRECISION).div(reserve0);\n        }\n        if (reserve1 == 0) { return 0; }\n        return reserve0.mul(Constants.PRICE_PRECISION).div(reserve1);\n    }\n}\n"
    },
    "contracts/core/storage/OrderBookStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./OrderBookAggregators.sol\";\nabstract contract OrderBookStorage is OrderBookAggregators{\n    /* constructor */\n    bool public isInitialized = false;\n    address public router;\n    address public vault;\n    address public weth;\n    address public usdm;\n    /* settings */\n    uint256 public minExecutionFee;\n    uint256 public minPurchaseTokenAmountUsd;\n    address public gov;\n    /* misc */\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n    modifier onlyGov() {\n        require(msg.sender == gov, Errors.ORDERBOOK_FORBIDDEN);\n        _;\n    }\n\n//    mapping (address => mapping(uint256 => DataTypes.IncreaseOrder)) public increaseOrders;\n//    mapping (address => uint256) public increaseOrdersIndex;\n//    mapping (address => mapping(uint256 => DataTypes.DecreaseOrder)) public decreaseOrders;\n//    mapping (address => uint256) public decreaseOrdersIndex;\n//    mapping (address => mapping(uint256 => DataTypes.SwapOrder)) public swapOrders;\n//    mapping (address => uint256) public swapOrdersIndex;\n}\n"
    },
    "contracts/core/settings/OrderBookSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../storage/OrderBookStorage.sol\";\nabstract contract OrderBookSettings is OrderBookStorage {\n    function setMinExecutionFee(uint256 _minExecutionFee) external onlyGov {\n        minExecutionFee = _minExecutionFee;\n        emit Events.UpdateMinExecutionFee(_minExecutionFee);\n    }\n    function setMinPurchaseTokenAmountUsd(uint256 _minPurchaseTokenAmountUsd) external onlyGov {\n        minPurchaseTokenAmountUsd = _minPurchaseTokenAmountUsd;\n        emit Events.UpdateMinPurchaseTokenAmountUsd(_minPurchaseTokenAmountUsd);\n    }\n    function setGov(address _gov) external onlyGov {\n        gov = _gov;\n        emit Events.UpdateGov(_gov);\n    }\n\n//    function createSwapOrder(address[] memory _path, uint256 _amountIn, uint256 _minOut, uint256 _triggerRatio, bool _triggerAboveThreshold, uint256 _executionFee, bool _shouldWrap, bool _shouldUnwrap) external payable nonReentrant {\n//        require(_path.length == 2 || _path.length == 3, Errors.ORDERBOOK_INVALID_PATH_LENGTH);\n//        require(_path[0] != _path[_path.length - 1], Errors.ORDERBOOK_INVALID_PATH);\n//        require(_amountIn > 0, Errors.ORDERBOOK_INVALID_AMOUNTIN);\n//        require(_executionFee >= minExecutionFee, Errors.ORDERBOOK_INSUFFICIENT_EXECUTION_FEE);\n//        _transferInETH();\n//        if (_shouldWrap) {\n//            require(_path[0] == weth, Errors.ORDERBOOK_ONLY_WETH_COULD_BE_WRAPPED);\n//            require(msg.value == _executionFee.add(_amountIn), Errors.ORDERBOOK_INCORRECT_VALUE_TRANSFERRED);\n//        } else {\n//            require(msg.value == _executionFee, Errors.ORDERBOOK_INCORRECT_EXECUTION_FEE_TRANSFERRED);\n//            IRouter(router).pluginTransfer(_path[0], msg.sender, address(this), _amountIn);\n//        }\n//        _createSwapOrder(msg.sender, _path, _amountIn, _minOut, _triggerRatio, _triggerAboveThreshold, _shouldUnwrap, _executionFee);\n//    }\n//    function executeSwapOrder(address _account, uint256 _orderIndex, address payable _feeReceiver) override external nonReentrant {\n//        DataTypes.SwapOrder memory order = swapOrders[_account][_orderIndex];\n//        require(order.account != address(0), Errors.ORDERBOOK_NON_EXISTENT_ORDER);\n//        if (order.triggerAboveThreshold) {\n//            require(\n//                validateSwapOrderPriceWithTriggerAboveThreshold(order.path, order.triggerRatio),\n//                Errors.ORDERBOOK_INVALID_PRICE_FOR_EXECUTION\n//            );\n//        }\n//        delete swapOrders[_account][_orderIndex];\n//        IERC20(order.path[0]).safeTransfer(vault, order.amountIn);\n//        uint256 _amountOut;\n//        if (order.path[order.path.length - 1] == weth && order.shouldUnwrap) {\n//            _amountOut = _swap(order.path, order.minOut, address(this));\n//            _transferOutETH(_amountOut, payable(order.account));\n//        } else {\n//            _amountOut = _swap(order.path, order.minOut, order.account);\n//        }\n//        _transferOutETH(order.executionFee, _feeReceiver);\n//        emit Events.ExecuteSwapOrder(_account, _orderIndex, order.path, order.amountIn, order.minOut, _amountOut, order.triggerRatio, order.triggerAboveThreshold, order.shouldUnwrap, order.executionFee);\n//    }\n//    function updateSwapOrder(uint256 _orderIndex, uint256 _minOut, uint256 _triggerRatio, bool _triggerAboveThreshold) external nonReentrant {\n//        DataTypes.SwapOrder storage order = swapOrders[msg.sender][_orderIndex];\n//        require(order.account != address(0), Errors.ORDERBOOK_NON_EXISTENT_ORDER);\n//        order.minOut = _minOut;\n//        order.triggerRatio = _triggerRatio;\n//        order.triggerAboveThreshold = _triggerAboveThreshold;\n//        emit Events.UpdateSwapOrder(msg.sender, _orderIndex, order.path, order.amountIn, _minOut, _triggerRatio, _triggerAboveThreshold, order.shouldUnwrap, order.executionFee);\n//    }\n//    function cancelSwapOrder(uint256 _orderIndex) public nonReentrant {\n//        DataTypes.SwapOrder memory order = swapOrders[msg.sender][_orderIndex];\n//        require(order.account != address(0), Errors.ORDERBOOK_NON_EXISTENT_ORDER);\n//        delete swapOrders[msg.sender][_orderIndex];\n//        if (order.path[0] == weth) {\n//            _transferOutETH(order.executionFee.add(order.amountIn), msg.sender);\n//        } else {\n//            IERC20(order.path[0]).safeTransfer(msg.sender, order.amountIn);\n//            _transferOutETH(order.executionFee, msg.sender);\n//        }\n//        emit Events.CancelSwapOrder(msg.sender, _orderIndex, order.path, order.amountIn, order.minOut, order.triggerRatio, order.triggerAboveThreshold, order.shouldUnwrap, order.executionFee);\n//    }\n//\n//    function createIncreaseOrder(address[] memory _path, uint256 _amountIn, address _indexToken, uint256 _minOut, uint256 _sizeDelta, address _collateralToken, bool _isLong, uint256 _triggerPrice, bool _triggerAboveThreshold, uint256 _executionFee, bool _shouldWrap) external payable nonReentrant {\n//        _transferInETH();\n//        require(_executionFee >= minExecutionFee, Errors.ORDERBOOK_INSUFFICIENT_EXECUTION_FEE);\n//        if (_shouldWrap) {\n//            require(_path[0] == weth, Errors.ORDERBOOK_ONLY_WETH_COULD_BE_WRAPPED);\n//            require(msg.value == _executionFee.add(_amountIn), Errors.ORDERBOOK_INCORRECT_VALUE_TRANSFERRED);\n//        } else {\n//            require(msg.value == _executionFee, Errors.ORDERBOOK_INCORRECT_EXECUTION_FEE_TRANSFERRED);\n//            IRouter(router).pluginTransfer(_path[0], msg.sender, address(this), _amountIn);\n//        }\n//        address _purchaseToken = _path[_path.length - 1];\n//        uint256 _purchaseTokenAmount;\n//        if (_path.length > 1) {\n//            require(_path[0] != _purchaseToken, Errors.ORDERBOOK_INVALID_PATH);\n//            IERC20(_path[0]).safeTransfer(vault, _amountIn);\n//            _purchaseTokenAmount = _swap(_path, _minOut, address(this));\n//        } else {\n//            _purchaseTokenAmount = _amountIn;\n//        }\n//        {\n//            uint256 _purchaseTokenAmountUsd = IVault(vault).tokenToUsdMin(_purchaseToken, _purchaseTokenAmount);\n//            require(_purchaseTokenAmountUsd >= minPurchaseTokenAmountUsd, Errors.ORDERBOOK_INSUFFICIENT_COLLATERAL);\n//        }\n//        _createIncreaseOrder(msg.sender, _purchaseToken, _purchaseTokenAmount, _collateralToken, _indexToken, _sizeDelta, _isLong, _triggerPrice, _triggerAboveThreshold, _executionFee);\n//    }\n//    function executeIncreaseOrder(address _address, uint256 _orderIndex, address payable _feeReceiver) override external nonReentrant {\n//        DataTypes.IncreaseOrder memory order = increaseOrders[_address][_orderIndex];\n//        require(order.account != address(0), Errors.ORDERBOOK_NON_EXISTENT_ORDER);\n//        (uint256 currentPrice, ) = validatePositionOrderPrice(order.triggerAboveThreshold, order.triggerPrice, order.indexToken, order.isLong, true);\n//        delete increaseOrders[_address][_orderIndex];\n//        IERC20(order.purchaseToken).safeTransfer(vault, order.purchaseTokenAmount);\n//        if (order.purchaseToken != order.collateralToken) {\n//            address[] memory path = new address[](2);\n//            path[0] = order.purchaseToken;\n//            path[1] = order.collateralToken;\n//            uint256 amountOut = _swap(path, 0, address(this));\n//            IERC20(order.collateralToken).safeTransfer(vault, amountOut);\n//        }\n//        IRouter(router).pluginIncreasePosition(order.account, order.collateralToken, order.indexToken, order.sizeDelta, order.isLong);\n//        _transferOutETH(order.executionFee, _feeReceiver);\n//        emit Events.ExecuteIncreaseOrder(order.account, _orderIndex, order.purchaseToken, order.purchaseTokenAmount, order.collateralToken, order.indexToken, order.sizeDelta, order.isLong, order.triggerPrice, order.triggerAboveThreshold, order.executionFee, currentPrice);\n//    }\n//    function updateIncreaseOrder(uint256 _orderIndex, uint256 _sizeDelta, uint256 _triggerPrice, bool _triggerAboveThreshold) external nonReentrant {\n//        DataTypes.IncreaseOrder storage order = increaseOrders[msg.sender][_orderIndex];\n//        require(order.account != address(0), Errors.ORDERBOOK_NON_EXISTENT_ORDER);\n//        order.triggerPrice = _triggerPrice;\n//        order.triggerAboveThreshold = _triggerAboveThreshold;\n//        order.sizeDelta = _sizeDelta;\n//        emit Events.UpdateIncreaseOrder(msg.sender, _orderIndex, order.collateralToken, order.indexToken, order.isLong, _sizeDelta, _triggerPrice, _triggerAboveThreshold);\n//    }\n//    function cancelIncreaseOrder(uint256 _orderIndex) public nonReentrant {\n//        DataTypes.IncreaseOrder memory order = increaseOrders[msg.sender][_orderIndex];\n//        require(order.account != address(0), Errors.ORDERBOOK_NON_EXISTENT_ORDER);\n//        delete increaseOrders[msg.sender][_orderIndex];\n//        if (order.purchaseToken == weth) {\n//            _transferOutETH(order.executionFee.add(order.purchaseTokenAmount), msg.sender);\n//        } else {\n//            IERC20(order.purchaseToken).safeTransfer(msg.sender, order.purchaseTokenAmount);\n//            _transferOutETH(order.executionFee, msg.sender);\n//        }\n//        emit Events.CancelIncreaseOrder(order.account, _orderIndex, order.purchaseToken, order.purchaseTokenAmount, order.collateralToken, order.indexToken, order.sizeDelta, order.isLong, order.triggerPrice, order.triggerAboveThreshold, order.executionFee);\n//    }\n//\n//    function createDecreaseOrder(address _indexToken, uint256 _sizeDelta, address _collateralToken, uint256 _collateralDelta, bool _isLong, uint256 _triggerPrice, bool _triggerAboveThreshold) external payable nonReentrant {\n//        _transferInETH();\n//        require(msg.value > minExecutionFee, Errors.ORDERBOOK_INSUFFICIENT_EXECUTION_FEE);\n//        _createDecreaseOrder(msg.sender, _collateralToken, _collateralDelta, _indexToken, _sizeDelta, _isLong, _triggerPrice, _triggerAboveThreshold);\n//    }\n//    function executeDecreaseOrder(address _address, uint256 _orderIndex, address payable _feeReceiver) override external nonReentrant {\n//        DataTypes.DecreaseOrder memory order = decreaseOrders[_address][_orderIndex];\n//        require(order.account != address(0), Errors.ORDERBOOK_NON_EXISTENT_ORDER);\n//        (uint256 currentPrice, ) = validatePositionOrderPrice(order.triggerAboveThreshold, order.triggerPrice, order.indexToken, !order.isLong, true);\n//        delete decreaseOrders[_address][_orderIndex];\n//        uint256 amountOut = IRouter(router).pluginDecreasePosition(order.account, order.collateralToken, order.indexToken, order.collateralDelta, order.sizeDelta, order.isLong, address(this));\n//        if (order.collateralToken == weth) {\n//            _transferOutETH(amountOut, payable(order.account));\n//        } else {\n//            IERC20(order.collateralToken).safeTransfer(order.account, amountOut);\n//        }\n//        _transferOutETH(order.executionFee, _feeReceiver);\n//        emit Events.ExecuteDecreaseOrder(order.account, _orderIndex, order.collateralToken, order.collateralDelta, order.indexToken, order.sizeDelta, order.isLong, order.triggerPrice, order.triggerAboveThreshold, order.executionFee, currentPrice);\n//    }\n//    function updateDecreaseOrder(uint256 _orderIndex, uint256 _collateralDelta, uint256 _sizeDelta, uint256 _triggerPrice, bool _triggerAboveThreshold) external nonReentrant {\n//        DataTypes.DecreaseOrder storage order = decreaseOrders[msg.sender][_orderIndex];\n//        require(order.account != address(0), Errors.ORDERBOOK_NON_EXISTENT_ORDER);\n//        order.triggerPrice = _triggerPrice;\n//        order.triggerAboveThreshold = _triggerAboveThreshold;\n//        order.sizeDelta = _sizeDelta;\n//        order.collateralDelta = _collateralDelta;\n//        emit Events.UpdateDecreaseOrder(msg.sender, _orderIndex, order.collateralToken, _collateralDelta, order.indexToken, _sizeDelta, order.isLong, _triggerPrice, _triggerAboveThreshold);\n//    }\n//    function cancelDecreaseOrder(uint256 _orderIndex) public nonReentrant {\n//        DataTypes.DecreaseOrder memory order = decreaseOrders[msg.sender][_orderIndex];\n//        require(order.account != address(0), Errors.ORDERBOOK_NON_EXISTENT_ORDER);\n//        delete decreaseOrders[msg.sender][_orderIndex];\n//        _transferOutETH(order.executionFee, msg.sender);\n//        emit Events.CancelDecreaseOrder(order.account, _orderIndex, order.collateralToken, order.collateralDelta, order.indexToken, order.sizeDelta, order.isLong, order.triggerPrice, order.triggerAboveThreshold, order.executionFee);\n//    }\n//\n//    function validateSwapOrderPriceWithTriggerAboveThreshold(address[] memory _path, uint256 _triggerRatio) public view returns (bool) {\n//        require(_path.length == 2 || _path.length == 3, Errors.ORDERBOOK_INVALID_PATH_LENGTH);\n//        address tokenA = _path[0];\n//        address tokenB = _path[_path.length - 1];\n//        uint256 tokenAPrice;\n//        uint256 tokenBPrice;\n//        if (tokenA == usdm) {\n//            tokenAPrice = getUsdmMinPrice(_path[1]);\n//        } else {\n//            tokenAPrice = IVault(vault).getMinPrice(tokenA);\n//        }\n//        if (tokenB == usdm) {\n//            tokenBPrice = Constants.PRICE_PRECISION;\n//        } else {\n//            tokenBPrice = IVault(vault).getMaxPrice(tokenB);\n//        }\n//        uint256 currentRatio = tokenBPrice.mul(Constants.PRICE_PRECISION).div(tokenAPrice);\n//        bool isValid = currentRatio > _triggerRatio;\n//        return isValid;\n//    }\n//    function validatePositionOrderPrice(bool _triggerAboveThreshold, uint256 _triggerPrice, address _indexToken, bool _maximizePrice, bool _raise) public view returns (uint256, bool) {\n//        uint256 currentPrice = _maximizePrice\n//            ? IVault(vault).getMaxPrice(_indexToken) : IVault(vault).getMinPrice(_indexToken);\n//        bool isPriceValid = _triggerAboveThreshold ? currentPrice > _triggerPrice : currentPrice < _triggerPrice;\n//        if (_raise) {\n//            require(isPriceValid, Errors.ORDERBOOK_INVALID_PRICE_FOR_EXECUTION);\n//        }\n//        return (currentPrice, isPriceValid);\n//    }\n//    function cancelMultiple(uint256[] memory _swapOrderIndexes, uint256[] memory _increaseOrderIndexes, uint256[] memory _decreaseOrderIndexes) external {\n//        for (uint256 i = 0; i < _swapOrderIndexes.length; i++) {\n//            cancelSwapOrder(_swapOrderIndexes[i]);\n//        }\n//        for (uint256 i = 0; i < _increaseOrderIndexes.length; i++) {\n//            cancelIncreaseOrder(_increaseOrderIndexes[i]);\n//        }\n//        for (uint256 i = 0; i < _decreaseOrderIndexes.length; i++) {\n//            cancelDecreaseOrder(_decreaseOrderIndexes[i]);\n//        }\n//    }\n\n//    function _transferInETH() internal {\n//        if (msg.value != 0) {\n//            IWETH(weth).deposit{value: msg.value}();\n//        }\n//    }\n//    function _transferOutETH(uint256 _amountOut, address payable _receiver) internal {\n//        IWETH(weth).withdraw(_amountOut);\n//        _receiver.sendValue(_amountOut);\n//    }\n//    function _swap(address[] memory _path, uint256 _minOut, address _receiver) internal returns (uint256) {\n//        if (_path.length == 2) {\n//            return _vaultSwap(_path[0], _path[1], _minOut, _receiver);\n//        }\n//        if (_path.length == 3) {\n//            uint256 midOut = _vaultSwap(_path[0], _path[1], 0, address(this));\n//            IERC20(_path[1]).safeTransfer(vault, midOut);\n//            return _vaultSwap(_path[1], _path[2], _minOut, _receiver);\n//        }\n//        revert(Errors.ORDERBOOK_INVALID_PATH_LENGTH);\n//    }\n//    function _vaultSwap(address _tokenIn, address _tokenOut, uint256 _minOut, address _receiver) internal returns (uint256) {\n//        uint256 amountOut;\n//        if (_tokenOut == usdm) {\n//            amountOut = IVault(vault).buyUSDM(_tokenIn, _receiver);\n//        } else if (_tokenIn == usdm) {\n//            amountOut = IVault(vault).sellUSDM(_tokenOut, _receiver);\n//        } else {\n//            amountOut = IVault(vault).swap(_tokenIn, _tokenOut, _receiver);\n//        }\n//        require(amountOut >= _minOut, Errors.ORDERBOOK_INSUFFICIENT_AMOUNTOUT);\n//        return amountOut;\n//    }\n//    function _createSwapOrder(address _account, address[] memory _path, uint256 _amountIn, uint256 _minOut, uint256 _triggerRatio, bool _triggerAboveThreshold, bool _shouldUnwrap, uint256 _executionFee) internal {\n//        uint256 _orderIndex = swapOrdersIndex[_account];\n//        DataTypes.SwapOrder memory order = DataTypes.SwapOrder(_account, _path, _amountIn, _minOut, _triggerRatio, _triggerAboveThreshold, _shouldUnwrap, _executionFee);\n//        swapOrdersIndex[_account] = _orderIndex.add(1);\n//        swapOrders[_account][_orderIndex] = order;\n//        emit Events.CreateSwapOrder(_account, _orderIndex, _path, _amountIn, _minOut, _triggerRatio, _triggerAboveThreshold, _shouldUnwrap, _executionFee);\n//    }\n//    function _createDecreaseOrder(address _account, address _collateralToken, uint256 _collateralDelta, address _indexToken, uint256 _sizeDelta, bool _isLong, uint256 _triggerPrice, bool _triggerAboveThreshold) internal {\n//        uint256 _orderIndex = decreaseOrdersIndex[_account];\n//        DataTypes.DecreaseOrder memory order = DataTypes.DecreaseOrder(_account, _collateralToken, _collateralDelta, _indexToken, _sizeDelta, _isLong, _triggerPrice, _triggerAboveThreshold, msg.value);\n//        decreaseOrdersIndex[_account] = _orderIndex.add(1);\n//        decreaseOrders[_account][_orderIndex] = order;\n//        emit Events.CreateDecreaseOrder(_account, _orderIndex, _collateralToken, _collateralDelta, _indexToken, _sizeDelta, _isLong, _triggerPrice, _triggerAboveThreshold, msg.value);\n//    }\n//    function _createIncreaseOrder(address _account, address _purchaseToken, uint256 _purchaseTokenAmount, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong, uint256 _triggerPrice, bool _triggerAboveThreshold, uint256 _executionFee) internal {\n//        uint256 _orderIndex = increaseOrdersIndex[msg.sender];\n//        DataTypes.IncreaseOrder memory order = DataTypes.IncreaseOrder(_account, _purchaseToken, _purchaseTokenAmount, _collateralToken, _indexToken, _sizeDelta, _isLong, _triggerPrice, _triggerAboveThreshold, _executionFee);\n//        increaseOrdersIndex[_account] = _orderIndex.add(1);\n//        increaseOrders[_account][_orderIndex] = order;\n//        emit Events.CreateIncreaseOrder(_account, _orderIndex, _purchaseToken, _purchaseTokenAmount, _collateralToken, _indexToken, _sizeDelta, _isLong, _triggerPrice, _triggerAboveThreshold, _executionFee);\n//    }\n\n//    function getSwapOrder(address _account, uint256 _orderIndex) override public view returns (address path0, address path1, address path2, uint256 amountIn, uint256 minOut, uint256 triggerRatio, bool triggerAboveThreshold, bool shouldUnwrap, uint256 executionFee) {\n//        DataTypes.SwapOrder memory order = swapOrders[_account][_orderIndex];\n//        return (order.path.length > 0 ? order.path[0] : address(0), order.path.length > 1 ? order.path[1] : address(0), order.path.length > 2 ? order.path[2] : address(0), order.amountIn, order.minOut, order.triggerRatio, order.triggerAboveThreshold, order.shouldUnwrap, order.executionFee);\n//    }\n//    function getUsdmMinPrice(address _otherToken) public view returns (uint256) {\n//        uint256 redemptionAmount = IVault(vault).getRedemptionAmount(_otherToken, Constants.USDM_PRECISION);\n//        uint256 otherTokenPrice = IVault(vault).getMinPrice(_otherToken);\n//        uint256 otherTokenDecimals = IVault(vault).tokenDecimals(_otherToken);\n//        return redemptionAmount.mul(otherTokenPrice).div(10 ** otherTokenDecimals);\n//    }\n//    function getDecreaseOrder(address _account, uint256 _orderIndex) override public view returns (address collateralToken, uint256 collateralDelta, address indexToken, uint256 sizeDelta, bool isLong, uint256 triggerPrice, bool triggerAboveThreshold, uint256 executionFee) {\n//        DataTypes.DecreaseOrder memory order = decreaseOrders[_account][_orderIndex];\n//        return (order.collateralToken, order.collateralDelta, order.indexToken, order.sizeDelta, order.isLong, order.triggerPrice, order.triggerAboveThreshold, order.executionFee);\n//    }\n//    function getIncreaseOrder(address _account, uint256 _orderIndex) override public view returns (address purchaseToken, uint256 purchaseTokenAmount, address collateralToken, address indexToken, uint256 sizeDelta, bool isLong, uint256 triggerPrice, bool triggerAboveThreshold, uint256 executionFee) {\n//        DataTypes.IncreaseOrder memory order = increaseOrders[_account][_orderIndex];\n//        return (order.purchaseToken, order.purchaseTokenAmount, order.collateralToken, order.indexToken, order.sizeDelta, order.isLong, order.triggerPrice, order.triggerAboveThreshold, order.executionFee);\n//    }\n}\n"
    },
    "contracts/core/OrderBook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./settings/OrderBookSettings.sol\";\ncontract OrderBook is OrderBookSettings {\n    constructor() public {\n        gov = msg.sender;\n    }\n    function initialize(address _router, address _vault, address _weth, address _usdm, uint256 _minExecutionFee, uint256 _minPurchaseTokenAmountUsd) external onlyGov {\n        require(!isInitialized, Errors.ORDERBOOK_ALREADY_INITIALIZED);\n        isInitialized = true;\n        router = _router;\n        vault = _vault;\n        weth = _weth;\n        usdm = _usdm;\n        minExecutionFee = _minExecutionFee;\n        minPurchaseTokenAmountUsd = _minPurchaseTokenAmountUsd;\n        emit Events.Initialize(_router, _vault, _weth, _usdm, _minExecutionFee, _minPurchaseTokenAmountUsd);\n    }\n    receive() external payable {\n        require(msg.sender == weth, Errors.ORDERBOOK_INVALID_SENDER);\n    }\n}\n"
    },
    "contracts/core/settings/BasePositionManagerSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../storage/BasePositionManagerStorage.sol\";\nimport \"./BasePositionManagerAggregator.sol\";\nabstract contract BasePositionManagerSettings is BasePositionManagerAggregator, BasePositionManagerStorage {\n    function setAdmin(address _admin) external onlyGov {\n        admin = _admin;\n        emit Events.SetAdmin(_admin);\n    }\n    function setDepositFee(uint256 _depositFee) external onlyAdmin {\n        depositFee = _depositFee;\n        emit Events.SetDepositFee(_depositFee);\n    }\n    function setIncreasePositionBufferBps(uint256 _increasePositionBufferBps) external onlyAdmin {\n        increasePositionBufferBps = _increasePositionBufferBps;\n        emit Events.SetIncreasePositionBufferBps(_increasePositionBufferBps);\n    }\n    function setReferralStorage(address _referralStorage) external onlyAdmin {\n        referralStorage = _referralStorage;\n        emit Events.SetReferralStorage(_referralStorage);\n    }\n    function setMaxGlobalSizes(address[] memory _tokens, uint256[] memory _longSizes, uint256[] memory _shortSizes) external onlyAdmin {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address token = _tokens[i];\n            maxGlobalLongSizes[token] = _longSizes[i];\n            maxGlobalShortSizes[token] = _shortSizes[i];\n        }\n        emit Events.SetMaxGlobalSizes(_tokens, _longSizes, _shortSizes);\n    }\n    function _validateMaxGlobalSize(address _indexToken, bool _isLong, uint256 _sizeDelta) internal view {\n        if (_sizeDelta == 0) {\n            return;\n        }\n        if (_isLong) {\n            uint256 maxGlobalLongSize = maxGlobalLongSizes[_indexToken];\n            if (maxGlobalLongSize > 0 && IVault(vault).guaranteedUsd(_indexToken).add(_sizeDelta) > maxGlobalLongSize) {\n                revert(Errors.BASEPOSITIONMANAGER_MAX_GLOBAL_LONGS_EXCEEDED);\n            }\n        } else {\n            uint256 maxGlobalShortSize = maxGlobalShortSizes[_indexToken];\n            if (maxGlobalShortSize > 0 && IVault(vault).globalShortSizes(_indexToken).add(_sizeDelta) > maxGlobalShortSize) {\n                revert(Errors.BASEPOSITIONMANAGER_MAX_GLOBAL_SHORTS_EXCEEDED);\n            }\n        }\n    }\n    function _increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong, uint256 _price) internal {\n        address _vault = vault;\n        uint256 markPrice = _isLong ? IVault(_vault).getMaxPrice(_indexToken) : IVault(_vault).getMinPrice(_indexToken);\n        if (_isLong) {\n            require(markPrice <= _price, Errors.BASEPOSITIONMANAGER_MARK_PRICE_HIGHER_THAN_LIMIT);\n        } else {\n            require(markPrice >= _price, Errors.BASEPOSITIONMANAGER_MARK_PRICE_LOWER_THAN_LIMIT);\n        }\n        _validateMaxGlobalSize(_indexToken, _isLong, _sizeDelta);\n        address timelock = IVault(_vault).gov();\n        IShortsTracker(shortsTracker).updateGlobalShortData(_account, _collateralToken, _indexToken, _isLong, _sizeDelta, markPrice, true);\n        ITimelock(timelock).enableLeverage(_vault);\n        IRouter(router).pluginIncreasePosition(_account, _collateralToken, _indexToken, _sizeDelta, _isLong);\n        ITimelock(timelock).disableLeverage(_vault);\n        _emitIncreasePositionReferral(_account, _sizeDelta);\n    }\n    function _decreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver, uint256 _price) internal returns (uint256) {\n        address _vault = vault;\n        uint256 markPrice = _isLong ? IVault(_vault).getMinPrice(_indexToken) : IVault(_vault).getMaxPrice(_indexToken);\n        if (_isLong) {\n            require(markPrice >= _price, Errors.BASEPOSITIONMANAGER_MARK_PRICE_LOWER_THAN_LIMIT);\n        } else {\n            require(markPrice <= _price, Errors.BASEPOSITIONMANAGER_MARK_PRICE_HIGHER_THAN_LIMIT);\n        }\n        address timelock = IVault(_vault).gov();\n        IShortsTracker(shortsTracker).updateGlobalShortData(_account, _collateralToken, _indexToken, _isLong, _sizeDelta, markPrice, false);\n        ITimelock(timelock).enableLeverage(_vault);\n        uint256 amountOut = IRouter(router).pluginDecreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n        ITimelock(timelock).disableLeverage(_vault);\n        _emitDecreasePositionReferral(_account, _sizeDelta);\n        return amountOut;\n    }\n    function _emitIncreasePositionReferral(address _account, uint256 _sizeDelta) internal {\n        address _referralStorage = referralStorage;\n        if (_referralStorage == address(0)) {\n            return;\n        }\n        (bytes32 referralCode, address referrer) = IReferralStorage(_referralStorage).getTraderReferralInfo(_account);\n        emit Events.IncreasePositionReferral(_account, _sizeDelta, IVault(vault).marginFeeBasisPoints(), referralCode, referrer);\n    }\n    function _emitDecreasePositionReferral(address _account, uint256 _sizeDelta) internal {\n        address _referralStorage = referralStorage;\n        if (_referralStorage == address(0)) {\n            return;\n        }\n        (bytes32 referralCode, address referrer) = IReferralStorage(_referralStorage).getTraderReferralInfo(_account);\n        if (referralCode == bytes32(0)) {\n            return;\n        }\n        emit Events.DecreasePositionReferral(_account, _sizeDelta, IVault(vault).marginFeeBasisPoints(), referralCode, referrer);\n    }\n    function _swap(address[] memory _path, uint256 _minOut, address _receiver) internal returns (uint256) {\n        if (_path.length == 2) {\n            return _vaultSwap(_path[0], _path[1], _minOut, _receiver);\n        }\n        revert(Errors.BASEPOSITIONMANAGER_INVALID_PATH_LENGTH);\n    }\n    function _vaultSwap(address _tokenIn, address _tokenOut, uint256 _minOut, address _receiver) internal returns (uint256) {\n        uint256 amountOut = IVault(vault).swap(_tokenIn, _tokenOut, _receiver);\n        require(amountOut >= _minOut, Errors.BASEPOSITIONMANAGER_INSUFFICIENT_AMOUNTOUT);\n        return amountOut;\n    }\n    function _transferInETH() internal {\n        if (msg.value != 0) {\n            IWETH(weth).deposit{value : msg.value}();\n        }\n    }\n    function _transferOutETHWithGasLimitIgnoreFail(uint256 _amountOut, address payable _receiver) internal {\n        IWETH(weth).withdraw(_amountOut);\n        _receiver.transfer(_amountOut);\n    }\n    function _collectFees(address _account, address[] memory _path, uint256 _amountIn, address _indexToken, bool _isLong, uint256 _sizeDelta) internal returns (uint256) {\n        bool shouldDeductFee = _shouldDeductFee(_account, _path, _amountIn, _indexToken, _isLong, _sizeDelta);\n        if (shouldDeductFee) {\n            uint256 afterFeeAmount = _amountIn.mul(BASIS_POINTS_DIVISOR.sub(depositFee)).div(BASIS_POINTS_DIVISOR);\n            uint256 feeAmount = _amountIn.sub(afterFeeAmount);\n            address feeToken = _path[_path.length - 1];\n            feeReserves[feeToken] = feeReserves[feeToken].add(feeAmount);\n            return afterFeeAmount;\n        }\n        return _amountIn;\n    }\n    function _shouldDeductFee(address _account, address[] memory _path, uint256 _amountIn, address _indexToken, bool _isLong, uint256 _sizeDelta) internal view returns (bool) {\n        if (!_isLong) {return false;}\n        if (_sizeDelta == 0) {return true;}\n        address collateralToken = _path[_path.length - 1];\n        IVault _vault = IVault(vault);\n        (uint256 size, uint256 collateral, , , , , ,) = _vault.getPosition(_account, collateralToken, _indexToken, _isLong);\n        if (size == 0) {return false;}\n        uint256 nextSize = size.add(_sizeDelta);\n        uint256 collateralDelta = _vault.tokenToUsdMin(collateralToken, _amountIn);\n        uint256 nextCollateral = collateral.add(collateralDelta);\n        uint256 prevLeverage = size.mul(BASIS_POINTS_DIVISOR).div(collateral);\n        uint256 nextLeverage = nextSize.mul(BASIS_POINTS_DIVISOR + increasePositionBufferBps).div(nextCollateral);\n        return nextLeverage < prevLeverage;\n    }\n}\n"
    },
    "contracts/core/BasePositionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./settings/BasePositionManagerSettings.sol\";\n\ncontract BasePositionManager is BasePositionManagerSettings {\n    \n    constructor(address _vault, address _router, address _shortsTracker, address _weth, uint256 _depositFee) public {\n        vault = _vault;\n        router = _router;\n        weth = _weth;\n        depositFee = _depositFee;\n        shortsTracker = _shortsTracker;\n        admin = msg.sender;\n    }\n    function withdrawFees(address _token, address _receiver) external onlyAdmin {\n        uint256 amount = feeReserves[_token];\n        if (amount == 0) {return;}\n        feeReserves[_token] = 0;\n        IERC20(_token).safeTransfer(_receiver, amount);\n        emit Events.WithdrawFees(_token, _receiver, amount);\n    }\n\n    function approve(address _token, address _spender, uint256 _amount) external onlyGov {\n        IERC20(_token).approve(_spender, _amount);\n    }\n\n    function sendValue(address payable _receiver, uint256 _amount) external onlyGov {\n        _receiver.sendValue(_amount);\n    }\n}\n"
    },
    "contracts/core/PositionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./BasePositionManager.sol\";\nimport \"./settings/PositionManagerSettings.sol\";\ncontract PositionManager is BasePositionManager, PositionManagerSettings {\n    constructor(address _vault, address _router, address _shortsTracker, address _weth, uint256 _depositFee, address _orderBook) public BasePositionManager(_vault, _router, _shortsTracker, _weth, _depositFee) {\n        orderBook = _orderBook;\n    }\n    function increasePosition(address[] memory _path, address _indexToken, uint256 _amountIn, uint256 _minOut, uint256 _sizeDelta, bool _isLong, uint256 _price) external nonReentrant onlyPartnersOrOpened {\n        require(_path.length == 1 || _path.length == 2, Errors.POSITIONMANAGER_INVALID_PATH_LENGTH);\n        if (_amountIn > 0) {\n            if (_path.length == 1) {\n                IRouter(router).pluginTransfer(_path[0], msg.sender, address(this), _amountIn);\n            } else {\n                IRouter(router).pluginTransfer(_path[0], msg.sender, vault, _amountIn);\n                _amountIn = _swap(_path, _minOut, address(this));\n            }\n            uint256 afterFeeAmount = _collectFees(msg.sender, _path, _amountIn, _indexToken, _isLong, _sizeDelta);\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, afterFeeAmount);\n        }\n        _increasePosition(msg.sender, _path[_path.length - 1], _indexToken, _sizeDelta, _isLong, _price);\n    }\n    function increasePositionETH(address[] memory _path, address _indexToken, uint256 _minOut, uint256 _sizeDelta, bool _isLong, uint256 _price) external payable nonReentrant onlyPartnersOrOpened {\n        require(_path.length == 1 || _path.length == 2, Errors.POSITIONMANAGER_INVALID_PATH_LENGTH);\n        require(_path[0] == weth, Errors.POSITIONMANAGER_INVALID_PATH);\n        if (msg.value > 0) {\n            _transferInETH();\n            uint256 _amountIn = msg.value;\n            if (_path.length > 1) {\n                IERC20(weth).safeTransfer(vault, msg.value);\n                _amountIn = _swap(_path, _minOut, address(this));\n            }\n            uint256 afterFeeAmount = _collectFees(msg.sender, _path, _amountIn, _indexToken, _isLong, _sizeDelta);\n            IERC20(_path[_path.length - 1]).safeTransfer(vault, afterFeeAmount);\n        }\n        _increasePosition(msg.sender, _path[_path.length - 1], _indexToken, _sizeDelta, _isLong, _price);\n    }\n    function decreasePosition(address[] memory _path, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver, uint256 _price, uint256 _minOut, bool _withdrawETH) external nonReentrant onlyPartnersOrOpened {\n        require(_path.length == 1 || _path.length == 2, Errors.POSITIONMANAGER_INVALID_PATH_LENGTH);\n        if (_withdrawETH) require(_path[_path.length - 1] == weth, Errors.POSITIONMANAGER_INVALID_PATH);\n        uint256 amountOut = _decreasePosition(msg.sender, _path[0], _indexToken, _collateralDelta, _sizeDelta, _isLong, address(this), _price);\n        if (amountOut > 0) {\n            if (_path.length > 1) {\n                IERC20(_path[0]).safeTransfer(vault, amountOut);\n                amountOut = _swap(_path, _minOut, address(this));\n            }\n            if (_withdrawETH) {\n                _transferOutETHWithGasLimitIgnoreFail(amountOut, payable(_receiver));\n            } else {\n                IERC20(_path[_path.length - 1]).safeTransfer(_receiver, amountOut);\n            }\n        }\n    }\n    function liquidatePosition(address _account, address _collateralToken, address _indexToken, bool _isLong, address _feeReceiver) external nonReentrant onlyLiquidator {\n        address _vault = vault;\n        address timelock = IVault(_vault).gov();\n        (uint256 size, , , , , , ,) = IVault(vault).getPosition(_account, _collateralToken, _indexToken, _isLong);\n        uint256 markPrice = _isLong ? IVault(_vault).getMinPrice(_indexToken) : IVault(_vault).getMaxPrice(_indexToken);\n        IShortsTracker(shortsTracker).updateGlobalShortData(_account, _collateralToken, _indexToken, _isLong, size, markPrice, false);\n        ITimelock(timelock).enableLeverage(_vault);\n        IVault(_vault).liquidatePosition(_account, _collateralToken, _indexToken, _isLong, _feeReceiver);\n        ITimelock(timelock).disableLeverage(_vault);\n    }\n}\n"
    },
    "contracts/core/VaultErrorController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"./interfaces/IVault.sol\";\nimport \"../access/Governable.sol\";\ncontract VaultErrorController is Governable {\n    function setErrors(IVault _vault, string[] calldata _errors) external onlyGov {\n        for (uint256 i = 0; i < _errors.length; i++) {\n            _vault.setError(i, _errors[i]);\n        }\n    }\n}"
    },
    "contracts/core/storage/ShortsTrackerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./ShortsTrackerAggregator.sol\";\nabstract contract ShortsTrackerStorage is ShortsTrackerAggregator {\n    uint256 public constant MAX_INT256 = uint256(type(int256).max);\n    bool public override isGlobalShortDataReady;\n    IVault public vault;\n    mapping (address => bool) public isHandler; /* handler address => bool */\n    mapping (bytes32 => bytes32) public data;\n    mapping (address => uint256) public override globalShortAveragePrices; /* tokenAddress => price*/\n    using SafeMath for uint256;\n    modifier onlyHandler() {\n        require(isHandler[msg.sender], Errors.SHORTSTRACKER_FORBIDDEN);\n        _;\n    }\n}\n"
    },
    "contracts/core/ShortsTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./storage/ShortsTrackerStorage.sol\";\ncontract ShortsTracker is ShortsTrackerStorage {\n    constructor(address _vault) public {\n        vault = IVault(_vault);\n    }\n    function updateGlobalShortData(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _sizeDelta, uint256 _markPrice, bool _isIncrease) override external onlyHandler {\n        if (_isLong || _sizeDelta == 0) {\n            return;\n        }\n        if (!isGlobalShortDataReady) {\n            return;\n        }\n        (uint256 globalShortSize, uint256 globalShortAveragePrice) = getNextGlobalShortData(_account, _collateralToken, _indexToken, _markPrice, _sizeDelta, _isIncrease);\n        _setGlobalShortAveragePrice(_indexToken, globalShortAveragePrice);\n        emit Events.GlobalShortDataUpdated(_indexToken, globalShortSize, globalShortAveragePrice);\n    }\n    /* settings */\n    function setHandler(address _handler, bool _isActive) external onlyGov {\n        require(_handler != address(0), Errors.SHORTSTRACKER_INVALID_HANDLER);\n        isHandler[_handler] = _isActive;\n    }\n    function _setGlobalShortAveragePrice(address _token, uint256 _averagePrice) internal {\n        globalShortAveragePrices[_token] = _averagePrice;\n    }\n    function setIsGlobalShortDataReady(bool value) external onlyGov {\n        isGlobalShortDataReady = value;\n    }\n    function setInitData(address[] calldata _tokens, uint256[] calldata _averagePrices) external onlyGov {\n        require(!isGlobalShortDataReady, Errors.SHORTSTRACKER_ALREADY_MIGRATED);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            globalShortAveragePrices[_tokens[i]] = _averagePrices[i];\n        }\n        isGlobalShortDataReady = true;\n    }\n    /* views */\n    function getGlobalShortDelta(address _token) public view returns (bool, uint256) {\n        uint256 size = vault.globalShortSizes(_token);\n        uint256 averagePrice = globalShortAveragePrices[_token];\n        if (size == 0) { return (false, 0); }\n        uint256 nextPrice = IVault(vault).getMaxPrice(_token);\n        uint256 priceDelta = averagePrice > nextPrice ? averagePrice.sub(nextPrice) : nextPrice.sub(averagePrice);\n        uint256 delta = size.mul(priceDelta).div(averagePrice);\n        bool hasProfit = averagePrice > nextPrice;\n        return (hasProfit, delta);\n    }\n    function getNextGlobalShortData(address _account, address _collateralToken, address _indexToken, uint256 _nextPrice, uint256 _sizeDelta, bool _isIncrease) override public view returns (uint256, uint256) {\n        int256 realisedPnl = getRealisedPnl(_account,_collateralToken, _indexToken, _sizeDelta, _isIncrease);\n        uint256 averagePrice = globalShortAveragePrices[_indexToken];\n        uint256 priceDelta = averagePrice > _nextPrice ? averagePrice.sub(_nextPrice) : _nextPrice.sub(averagePrice);\n        uint256 nextSize;\n        uint256 delta;\n        {\n            uint256 size = vault.globalShortSizes(_indexToken);\n            nextSize = _isIncrease ? size.add(_sizeDelta) : size.sub(_sizeDelta);\n            if (nextSize == 0) {\n                return (0, 0);\n            }\n            if (averagePrice == 0) {\n                return (nextSize, _nextPrice);\n            }\n            delta = size.mul(priceDelta).div(averagePrice);\n        }\n        uint256 nextAveragePrice = _getNextGlobalAveragePrice(averagePrice, _nextPrice, nextSize, delta, realisedPnl);\n        return (nextSize, nextAveragePrice);\n    }\n    function getRealisedPnl(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isIncrease) public view returns (int256) {\n        if (_isIncrease) {\n            return 0;\n        }\n        IVault _vault = vault;\n        (uint256 size, , uint256 averagePrice, , , , , uint256 lastIncreasedTime) = _vault.getPosition(_account, _collateralToken, _indexToken, false);\n        (bool hasProfit, uint256 delta) = _vault.getDelta(_indexToken, size, averagePrice, false, lastIncreasedTime);\n        uint256 adjustedDelta = _sizeDelta.mul(delta).div(size);\n        require(adjustedDelta < MAX_INT256, Errors.SHORTSTRACKER_OVERFLOW);\n        return hasProfit ? int256(adjustedDelta) : -int256(adjustedDelta);\n    }\n    function _getNextGlobalAveragePrice(uint256 _averagePrice, uint256 _nextPrice, uint256 _nextSize, uint256 _delta, int256 _realisedPnl) public pure returns (uint256) {\n        (bool hasProfit, uint256 nextDelta) = _getNextDelta(_delta, _averagePrice, _nextPrice, _realisedPnl);\n        uint256 nextAveragePrice = _nextPrice\n            .mul(_nextSize)\n            .div(hasProfit ? _nextSize.sub(nextDelta) : _nextSize.add(nextDelta));\n        return nextAveragePrice;\n    }\n    function _getNextDelta(uint256 _delta, uint256 _averagePrice, uint256 _nextPrice, int256 _realisedPnl) internal pure returns (bool, uint256) {\n        bool hasProfit = _averagePrice > _nextPrice;\n        if (hasProfit) {\n            if (_realisedPnl > 0) {\n                if (uint256(_realisedPnl) > _delta) {\n                    _delta = uint256(_realisedPnl).sub(_delta);\n                    hasProfit = false;\n                } else {\n                    _delta = _delta.sub(uint256(_realisedPnl));\n                }\n            } else {\n                _delta = _delta.add(uint256(-_realisedPnl));\n            }\n            return (hasProfit, _delta);\n        }\n        if (_realisedPnl > 0) {\n            _delta = _delta.add(uint256(_realisedPnl));\n        } else {\n            if (uint256(-_realisedPnl) > _delta) {\n                _delta = uint256(-_realisedPnl).sub(_delta);\n                hasProfit = true;\n            } else {\n                _delta = _delta.sub(uint256(-_realisedPnl));\n            }\n        }\n        return (hasProfit, _delta);\n    }\n}\n"
    },
    "contracts/core/storage/RewardRouterV2Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./RewardRouterV2Aggregator.sol\";\nabstract contract RewardRouterV2Storage is RewardRouterV2Aggregator {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n    bool public isInitialized;\n    address public weth;\n    address public mold;\n    address public esMold;\n    address public bnMold;\n    address public mlp;\n    address public stakedMoldTracker;\n    address public bonusMoldTracker;\n    address public feeMoldTracker;\n    address public stakedMlpTracker;\n    address public feeMlpTracker;\n    address public mlpManager;\n    address public mlpVester;\n    address public moldVester;\n    mapping (address => address) public pendingReceivers;\n}\n"
    },
    "contracts/core/settings/RewardRouterV2Settings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"../storage/RewardRouterV2Storage.sol\";\nabstract contract RewardRouterV2Settings is RewardRouterV2Storage {\n    function initialize(address _weth, address _mold, address _esMold, address _bnMold, address _mlp, address _stakedMoldTracker, address _bonusMoldTracker, address _feeMoldTracker, address _feeMlpTracker, address _stakedMlpTracker, address _mlpManager, address _moldVester, address _mlpVester) external onlyGov {\n        require(!isInitialized, Errors.REWARDROUTER_ALREADY_INITIALIZED);\n        isInitialized = true;\n        weth = _weth;\n        mold = _mold;\n        esMold = _esMold;\n        bnMold = _bnMold;\n        mlp = _mlp;\n        stakedMoldTracker = _stakedMoldTracker;\n        bonusMoldTracker = _bonusMoldTracker;\n        feeMoldTracker = _feeMoldTracker;\n        feeMlpTracker = _feeMlpTracker;\n        stakedMlpTracker = _stakedMlpTracker;\n        mlpManager = _mlpManager;\n        moldVester = _moldVester;\n        mlpVester = _mlpVester;\n    }\n//    function withdrawToken(address _token, address _account, uint256 _amount) external onlyGov {\n//        IERC20(_token).safeTransfer(_account, _amount);\n//    }\n//    function batchStakeMoldForAccount(address[] memory _accounts, uint256[] memory _amounts) external nonReentrant onlyGov {\n//        address _mold = mold;\n//        for (uint256 i = 0; i < _accounts.length; i++) {\n//            _stakeMold(msg.sender, _accounts[i], _mold, _amounts[i]);\n//        }\n//    }\n//    function stakeMoldForAccount(address _account, uint256 _amount) external nonReentrant onlyGov {\n//        _stakeMold(msg.sender, _account, mold, _amount);\n//    }\n//    function stakeMold(uint256 _amount) external nonReentrant {\n//        _stakeMold(msg.sender, msg.sender, mold, _amount);\n//    }\n//    function stakeEsMold(uint256 _amount) external nonReentrant {\n//        _stakeMold(msg.sender, msg.sender, esMold, _amount);\n//    }\n//    function unstakeMold(uint256 _amount) external nonReentrant {\n//        _unstakeMold(msg.sender, mold, _amount, true);\n//    }\n//    function unstakeEsMold(uint256 _amount) external nonReentrant {\n//        _unstakeMold(msg.sender, esMold, _amount, true);\n//    }\n//    function claim() external nonReentrant {\n//        address account = msg.sender;\n//        IRewardTracker(feeMoldTracker).claimForAccount(account, account);\n//        IRewardTracker(feeMlpTracker).claimForAccount(account, account);\n//        IRewardTracker(stakedMoldTracker).claimForAccount(account, account);\n//        IRewardTracker(stakedMlpTracker).claimForAccount(account, account);\n//    }\n//    function claimEsMold() external nonReentrant {\n//        address account = msg.sender;\n//        IRewardTracker(stakedMoldTracker).claimForAccount(account, account);\n//        IRewardTracker(stakedMlpTracker).claimForAccount(account, account);\n//    }\n//    function claimFees() external nonReentrant {\n//        address account = msg.sender;\n//\n//        IRewardTracker(feeMoldTracker).claimForAccount(account, account);\n//        IRewardTracker(feeMlpTracker).claimForAccount(account, account);\n//    }\n//    function compound() external nonReentrant {\n//        _compound(msg.sender);\n//    }\n//    function compoundForAccount(address _account) external nonReentrant onlyGov {\n//        _compound(_account);\n//    }\n//    function handleRewards(bool _shouldClaimMold, bool _shouldStakeMold, bool _shouldClaimEsMold, bool _shouldStakeEsMold, bool _shouldStakeMultiplierPoints, bool _shouldClaimWeth, bool _shouldConvertWethToEth) external nonReentrant {\n//        address account = msg.sender;\n//        uint256 moldAmount = 0;\n//        if (_shouldClaimMold) {\n//            uint256 moldAmount0 = IVester(moldVester).claimForAccount(account, account);\n//            uint256 moldAmount1 = IVester(mlpVester).claimForAccount(account, account);\n//            moldAmount = moldAmount0.add(moldAmount1);\n//        }\n//        if (_shouldStakeMold && moldAmount > 0) {\n//            _stakeMold(account, account, mold, moldAmount);\n//        }\n//        uint256 esMoldAmount = 0;\n//        if (_shouldClaimEsMold) {\n//            uint256 esMoldAmount0 = IRewardTracker(stakedMoldTracker).claimForAccount(account, account);\n//            uint256 esMoldAmount1 = IRewardTracker(stakedMlpTracker).claimForAccount(account, account);\n//            esMoldAmount = esMoldAmount0.add(esMoldAmount1);\n//        }\n//        if (_shouldStakeEsMold && esMoldAmount > 0) {\n//            _stakeMold(account, account, esMold, esMoldAmount);\n//        }\n//        if (_shouldStakeMultiplierPoints) {\n//            uint256 bnMoldAmount = IRewardTracker(bonusMoldTracker).claimForAccount(account, account);\n//            if (bnMoldAmount > 0) {\n//                IRewardTracker(feeMoldTracker).stakeForAccount(account, account, bnMold, bnMoldAmount);\n//            }\n//        }\n//        if (_shouldClaimWeth) {\n//            if (_shouldConvertWethToEth) {\n//                uint256 weth0 = IRewardTracker(feeMoldTracker).claimForAccount(account, address(this));\n//                uint256 weth1 = IRewardTracker(feeMlpTracker).claimForAccount(account, address(this));\n//                uint256 wethAmount = weth0.add(weth1);\n//                IWETH(weth).withdraw(wethAmount);\n//                payable(account).sendValue(wethAmount);\n//            } else {\n//                IRewardTracker(feeMoldTracker).claimForAccount(account, account);\n//                IRewardTracker(feeMlpTracker).claimForAccount(account, account);\n//            }\n//        }\n//    }\n//    function batchCompoundForAccounts(address[] memory _accounts) external nonReentrant onlyGov {\n//        for (uint256 i = 0; i < _accounts.length; i++) {\n//            _compound(_accounts[i]);\n//        }\n//    }\n//    function signalTransfer(address _receiver) external nonReentrant {\n//        require(IERC20(moldVester).balanceOf(msg.sender) == 0, Errors.REWARDROUTER_SENDER_HAS_VESTED_TOKENS);\n//        require(IERC20(mlpVester).balanceOf(msg.sender) == 0, Errors.REWARDROUTER_SENDER_HAS_VESTED_TOKENS);\n//        _validateReceiver(_receiver);\n//        pendingReceivers[msg.sender] = _receiver;\n//    }\n//    function acceptTransfer(address _sender) external nonReentrant {\n//        require(IERC20(moldVester).balanceOf(_sender) == 0, Errors.REWARDROUTER_SENDER_HAS_VESTED_TOKENS);\n//        require(IERC20(mlpVester).balanceOf(_sender) == 0, Errors.REWARDROUTER_SENDER_HAS_VESTED_TOKENS);\n//        address receiver = msg.sender;\n//        require(pendingReceivers[_sender] == receiver, Errors.REWARDROUTER_TRANSFER_NOT_SIGNALLED);\n//        delete pendingReceivers[_sender];\n//        _validateReceiver(receiver);\n//        _compound(_sender);\n//        uint256 stakedMold = IRewardTracker(stakedMoldTracker).depositBalances(_sender, mold);\n//        if (stakedMold > 0) {\n//            _unstakeMold(_sender, mold, stakedMold, false);\n//            _stakeMold(_sender, receiver, mold, stakedMold);\n//        }\n//        uint256 stakedEsMold = IRewardTracker(stakedMoldTracker).depositBalances(_sender, esMold);\n//        if (stakedEsMold > 0) {\n//            _unstakeMold(_sender, esMold, stakedEsMold, false);\n//            _stakeMold(_sender, receiver, esMold, stakedEsMold);\n//        }\n//        uint256 stakedBnMold = IRewardTracker(feeMoldTracker).depositBalances(_sender, bnMold);\n//        if (stakedBnMold > 0) {\n//            IRewardTracker(feeMoldTracker).unstakeForAccount(_sender, bnMold, stakedBnMold, _sender);\n//            IRewardTracker(feeMoldTracker).stakeForAccount(_sender, receiver, bnMold, stakedBnMold);\n//        }\n//        uint256 esMoldBalance = IERC20(esMold).balanceOf(_sender);\n//        if (esMoldBalance > 0) {\n//            IERC20(esMold).transferFrom(_sender, receiver, esMoldBalance);\n//        }\n//        uint256 mlpAmount = IRewardTracker(feeMlpTracker).depositBalances(_sender, mlp);\n//        if (mlpAmount > 0) {\n//            IRewardTracker(stakedMlpTracker).unstakeForAccount(_sender, feeMlpTracker, mlpAmount, _sender);\n//            IRewardTracker(feeMlpTracker).unstakeForAccount(_sender, mlp, mlpAmount, _sender);\n//\n//            IRewardTracker(feeMlpTracker).stakeForAccount(_sender, receiver, mlp, mlpAmount);\n//            IRewardTracker(stakedMlpTracker).stakeForAccount(receiver, receiver, feeMlpTracker, mlpAmount);\n//        }\n//        IVester(moldVester).transferStakeValues(_sender, receiver);\n//        IVester(mlpVester).transferStakeValues(_sender, receiver);\n//    }\n//    function _validateReceiver(address _receiver) private view {\n//        require(IRewardTracker(stakedMoldTracker).averageStakedAmounts(_receiver) == 0, Errors.REWARDROUTER_STAKEDMOLDTRACKER_AVERAGESTAKEDAMOUNTS_GREATER_0);\n//        require(IRewardTracker(stakedMoldTracker).cumulativeRewards(_receiver) == 0, Errors.REWARDROUTER_STAKEDMOLDTRACKER_CUMULATIVEREWARDS_GREATER_0);\n//        require(IRewardTracker(bonusMoldTracker).averageStakedAmounts(_receiver) == 0, Errors.REWARDROUTER_BONUSMOLDTRACKER_AVERAGESTAKEDAMOUNTS_GREATER_0);\n//        require(IRewardTracker(bonusMoldTracker).cumulativeRewards(_receiver) == 0, Errors.REWARDROUTER_BONUSMOLDTRACKER_CUMULATIVEREWARDS_GREATER_0);\n//        require(IRewardTracker(feeMoldTracker).averageStakedAmounts(_receiver) == 0, Errors.REWARDROUTER_FEEMOLDTRACKER_AVERAGESTAKEDAMOUNTS_GREATER_0);\n//        require(IRewardTracker(feeMoldTracker).cumulativeRewards(_receiver) == 0, Errors.REWARDROUTER_FEEMOLDTRACKER_CUMULATIVEREWARDS_GREATER_0);\n//        require(IVester(moldVester).transferredAverageStakedAmounts(_receiver) == 0, Errors.REWARDROUTER_MOLDVESTER_TRANSFERREDAVERAGESTAKEDAMOUNTS_GREATER_0);\n//        require(IVester(moldVester).transferredCumulativeRewards(_receiver) == 0, Errors.REWARDROUTER_MOLDVESTER_TRANSFERREDCUMULATIVEREWARDS_GREATER_0);\n//        require(IRewardTracker(stakedMlpTracker).averageStakedAmounts(_receiver) == 0, Errors.REWARDROUTER_STAKEDMLPTRACKER_AVERAGESTAKEDAMOUNTS_GREATER_0);\n//        require(IRewardTracker(stakedMlpTracker).cumulativeRewards(_receiver) == 0, Errors.REWARDROUTER_STAKEDMLPTRACKER_CUMULATIVEREWARDS_GREATER_0);\n//        require(IRewardTracker(feeMlpTracker).averageStakedAmounts(_receiver) == 0, Errors.REWARDROUTER_FEEMLPTRACKER_AVERAGESTAKEDAMOUNTS_GREATER_0);\n//        require(IRewardTracker(feeMlpTracker).cumulativeRewards(_receiver) == 0, Errors.REWARDROUTER_FEEMLPTRACKER_CUMULATIVEREWARDS_GREATER_0);\n//        require(IVester(mlpVester).transferredAverageStakedAmounts(_receiver) == 0, Errors.REWARDROUTER_MOLDVESTER_TRANSFERREDAVERAGESTAKEDAMOUNTS_GREATER_0);\n//        require(IVester(mlpVester).transferredCumulativeRewards(_receiver) == 0, Errors.REWARDROUTER_MOLDVESTER_TRANSFERREDCUMULATIVEREWARDS_GREATER_0);\n//        require(IERC20(moldVester).balanceOf(_receiver) == 0, Errors.REWARDROUTER_MOLDVESTER_BALANCE_GREATER_0);\n//        require(IERC20(mlpVester).balanceOf(_receiver) == 0, Errors.REWARDROUTER_MLPVESTER_BALANCE_GREATER_0);\n//    }\n//    function _compound(address _account) private {\n//        _compoundMold(_account);\n//        _compoundMlp(_account);\n//    }\n//    function _compoundMold(address _account) private {\n//        uint256 esMoldAmount = IRewardTracker(stakedMoldTracker).claimForAccount(_account, _account);\n//        if (esMoldAmount > 0) {\n//            _stakeMold(_account, _account, esMold, esMoldAmount);\n//        }\n//        uint256 bnMoldAmount = IRewardTracker(bonusMoldTracker).claimForAccount(_account, _account);\n//        if (bnMoldAmount > 0) {\n//            IRewardTracker(feeMoldTracker).stakeForAccount(_account, _account, bnMold, bnMoldAmount);\n//        }\n//    }\n//    function _compoundMlp(address _account) private {\n//        uint256 esMoldAmount = IRewardTracker(stakedMlpTracker).claimForAccount(_account, _account);\n//        if (esMoldAmount > 0) {\n//            _stakeMold(_account, _account, esMold, esMoldAmount);\n//        }\n//    }\n//    function _stakeMold(address _fundingAccount, address _account, address _token, uint256 _amount) private {\n//        require(_amount > 0, Errors.REWARDROUTER_INVALID_AMOUNT);\n//        IRewardTracker(stakedMoldTracker).stakeForAccount(_fundingAccount, _account, _token, _amount);\n//        IRewardTracker(bonusMoldTracker).stakeForAccount(_account, _account, stakedMoldTracker, _amount);\n//        IRewardTracker(feeMoldTracker).stakeForAccount(_account, _account, bonusMoldTracker, _amount);\n//        emit Events.StakeMold(_account, _token, _amount);\n//    }\n//    function _unstakeMold(address _account, address _token, uint256 _amount, bool _shouldReduceBnMold) private {\n//        require(_amount > 0, Errors.REWARDROUTER_INVALID_AMOUNT);\n//        uint256 balance = IRewardTracker(stakedMoldTracker).stakedAmounts(_account);\n//        IRewardTracker(feeMoldTracker).unstakeForAccount(_account, bonusMoldTracker, _amount, _account);\n//        IRewardTracker(bonusMoldTracker).unstakeForAccount(_account, stakedMoldTracker, _amount, _account);\n//        IRewardTracker(stakedMoldTracker).unstakeForAccount(_account, _token, _amount, _account);\n//        if (_shouldReduceBnMold) {\n//            uint256 bnMoldAmount = IRewardTracker(bonusMoldTracker).claimForAccount(_account, _account);\n//            if (bnMoldAmount > 0) {\n//                IRewardTracker(feeMoldTracker).stakeForAccount(_account, _account, bnMold, bnMoldAmount);\n//            }\n//            uint256 stakedBnMold = IRewardTracker(feeMoldTracker).depositBalances(_account, bnMold);\n//            if (stakedBnMold > 0) {\n//                uint256 reductionAmount = stakedBnMold.mul(_amount).div(balance);\n//                IRewardTracker(feeMoldTracker).unstakeForAccount(_account, bnMold, reductionAmount, _account);\n//                IMintable(bnMold).burn(_account, reductionAmount);\n//            }\n//        }\n//        emit Events.UnstakeMold(_account, _token, _amount);\n//    }\n}\n"
    },
    "contracts/staking/RewardRouterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../core/settings/RewardRouterV2Settings.sol\";\n\ncontract RewardRouterV2 is RewardRouterV2Settings {\n    \n    receive() external payable {\n        require(msg.sender == weth, Errors.ROUTER_INVALID_SENDER);\n    }\n\n    function mintAndStakeMlp(address _token, uint256 _amount, uint256 _minUsdm, uint256 _minMlp) external nonReentrant returns (uint256) {\n        require(_amount > 0, Errors.REWARDROUTER_INVALID_AMOUNT);\n        address account = msg.sender;\n        uint256 mlpAmount = IMlpManager(mlpManager).addLiquidityForAccount(account, account, _token, _amount, _minUsdm, _minMlp);\n        return mlpAmount;\n    }\n\n    function mintAndStakeMlpETH(uint256 _minUsdm, uint256 _minMlp) external payable nonReentrant returns (uint256) {\n        require(msg.value > 0, Errors.REWARDROUTER_INVALID_MSG_VALUE);\n        IWETH(weth).deposit{value : msg.value}();\n        IERC20(weth).approve(mlpManager, msg.value);\n        address account = msg.sender;\n        uint256 mlpAmount = IMlpManager(mlpManager).addLiquidityForAccount(address(this), account, weth, msg.value, _minUsdm, _minMlp);\n        return mlpAmount;\n    }\n\n    function unstakeAndRedeemMlp(address _tokenOut, uint256 _mlpAmount, uint256 _minOut, address _receiver) external nonReentrant returns (uint256) {\n        require(_mlpAmount > 0, Errors.REWARDROUTER_INVALID_MLPAMOUNT);\n        address account = msg.sender;\n//        IRewardTracker(stakedMlpTracker).unstakeForAccount(account, feeMlpTracker, _mlpAmount, account);\n//        IRewardTracker(feeMlpTracker).unstakeForAccount(account, mlp, _mlpAmount, account);\n        uint256 amountOut = IMlpManager(mlpManager).removeLiquidityForAccount(account, _tokenOut, _mlpAmount, _minOut, _receiver);\n        emit Events.UnstakeMlp(account, _mlpAmount);\n        return amountOut;\n    }\n\n    function unstakeAndRedeemMlpETH(uint256 _mlpAmount, uint256 _minOut, address payable _receiver) external nonReentrant returns (uint256) {\n        require(_mlpAmount > 0, Errors.REWARDROUTER_INVALID_MLPAMOUNT);\n        address account = msg.sender;\n//        IRewardTracker(stakedMlpTracker).unstakeForAccount(account, feeMlpTracker, _mlpAmount, account);\n//        IRewardTracker(feeMlpTracker).unstakeForAccount(account, mlp, _mlpAmount, account);\n        uint256 amountOut = IMlpManager(mlpManager).removeLiquidityForAccount(account, weth, _mlpAmount, _minOut, address(this));\n        IWETH(weth).withdraw(amountOut);\n        _receiver.sendValue(amountOut);\n        emit Events.UnstakeMlp(account, _mlpAmount);\n        return amountOut;\n    }\n}\n"
    },
    "contracts/core/storage/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./VaultAggregators.sol\";\n\nabstract contract VaultStorage is VaultAggregators {\n    \n    uint256 public override maxLeverage = 50 * 10000; // 50x\n    uint256 public override taxBasisPoints = 50; // 0.5%\n    uint256 public override stableTaxBasisPoints = 20; // 0.2%\n    uint256 public override mintBurnFeeBasisPoints = 30; // 0.3%\n    uint256 public override swapFeeBasisPoints = 30; // 0.3%\n    uint256 public override stableSwapFeeBasisPoints = 4; // 0.04%\n    uint256 public override marginFeeBasisPoints = 10; // 0.1%\n    uint256 public override fundingInterval = 1 hours;\n    uint256 public override liquidationFeeUsd;\n    uint256 public override whitelistedTokenCount;\n    uint256 public override fundingRateFactor;\n    uint256 public override stableFundingRateFactor;\n    uint256 public override totalTokenWeights;\n    uint256 public override maxGasPrice;\n    uint256 public override minProfitTime;\n    bool public override isSwapEnabled = true;\n    bool public override isLeverageEnabled = true;\n    bool public override hasDynamicFees = false;\n    bool public includeAmmPrice = true;\n    bool public useSwapPricing = false;\n    bool public override inManagerMode = false;\n    bool public override inPrivateLiquidationMode = false;\n    bool public override isInitialized;\n    IVaultUtils public vaultUtils;\n    address public errorController;\n    address public override router;\n    address public override priceFeed;\n    address public override usdm;\n    address public override gov;\n    address[] public override allWhitelistedTokens;\n    mapping(address => mapping(address => bool)) public override approvedRouters;\n    mapping(address => bool) public override isLiquidator;\n    mapping(address => bool) public override isManager;\n    mapping(address => bool) public override whitelistedTokens;\n    mapping(address => uint256) public override tokenDecimals;\n    mapping(address => uint256) public override minProfitBasisPoints;\n    mapping(address => bool) public override stableTokens;\n    mapping(address => bool) public override shortableTokens;\n    mapping(address => uint256) public override tokenBalances;\n    mapping(address => uint256) public override tokenWeights;\n    mapping(address => uint256) public override usdmAmounts;\n    mapping(address => uint256) public override maxUsdmAmounts;\n    mapping(address => uint256) public override poolAmounts;\n    mapping(address => uint256) public override reservedAmounts; // all debt - amount\n    mapping(address => uint256) public override bufferAmounts;\n    mapping(address => uint256) public override guaranteedUsd; // long debt - usd\n    mapping(address => uint256) public override cumulativeFundingRates;  // borrow fee\n    mapping(address => uint256) public override lastFundingTimes;\n    mapping(bytes32 => DataTypes.Position) public positions; //done\n    mapping(address => uint256) public override feeReserves; // fee token=>balance\n    mapping(address => uint256) public override globalShortSizes; // short debt = usd\n    mapping(address => uint256) public override globalShortAveragePrices;\n    mapping(address => uint256) public override maxGlobalShortSizes;\n    mapping(uint256 => string) public errors;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n}\n"
    },
    "contracts/core/settings/VaultSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../storage/VaultStorage.sol\";\nabstract contract VaultSettings is VaultStorage {\n    function _onlyGov() internal view {\n        _validate(msg.sender == gov, 53);\n    }\n    function setVaultUtils(IVaultUtils _vaultUtils) external override {\n        _onlyGov();\n        vaultUtils = _vaultUtils;\n    }\n    function setErrorController(address _errorController) external {\n        _onlyGov();\n        errorController = _errorController;\n    }\n    function setError(uint256 _errorCode, string calldata _error) external override {\n        require(msg.sender == errorController, Errors.VAULT_INVALID_ERRORCONTROLLER);\n        errors[_errorCode] = _error;\n    }\n    function setInManagerMode(bool _inManagerMode) external override {\n        _onlyGov();\n        inManagerMode = _inManagerMode;\n    }\n    function setManager(address _manager, bool _isManager) external override {\n        _onlyGov();\n        isManager[_manager] = _isManager;\n    }\n    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external override {\n        _onlyGov();\n        inPrivateLiquidationMode = _inPrivateLiquidationMode;\n    }\n    function setLiquidator(address _liquidator, bool _isActive) external override {\n        _onlyGov();\n        isLiquidator[_liquidator] = _isActive;\n    }\n    function setIsSwapEnabled(bool _isSwapEnabled) external override {\n        _onlyGov();\n        isSwapEnabled = _isSwapEnabled;\n    }\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external override {\n        _onlyGov();\n        isLeverageEnabled = _isLeverageEnabled;\n    }\n    function setMaxGasPrice(uint256 _maxGasPrice) external override {\n        _onlyGov();\n        maxGasPrice = _maxGasPrice;\n    }\n    function setGov(address _gov) external {\n        _onlyGov();\n        gov = _gov;\n    }\n    function setPriceFeed(address _priceFeed) external override {\n        _onlyGov();\n        priceFeed = _priceFeed;\n    }\n    function setMaxLeverage(uint256 _maxLeverage) external override {\n        _onlyGov();\n        _validate(_maxLeverage > Constants.MIN_LEVERAGE, 2);\n        maxLeverage = _maxLeverage;\n    }\n    function setBufferAmount(address _token, uint256 _amount) external override {\n        _onlyGov();\n        bufferAmounts[_token] = _amount;\n    }\n    function setMaxGlobalShortSize(address _token, uint256 _amount) external override {\n        _onlyGov();\n        maxGlobalShortSizes[_token] = _amount;\n    }\n    function setFees(uint256 _taxBasisPoints, uint256 _stableTaxBasisPoints, uint256 _mintBurnFeeBasisPoints, uint256 _swapFeeBasisPoints, uint256 _stableSwapFeeBasisPoints, uint256 _marginFeeBasisPoints, uint256 _liquidationFeeUsd, uint256 _minProfitTime, bool _hasDynamicFees) external override {\n        _onlyGov();\n        _validate(_taxBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 3);\n        _validate(_stableTaxBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 4);\n        _validate(_mintBurnFeeBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 5);\n        _validate(_swapFeeBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 6);\n        _validate(_stableSwapFeeBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 7);\n        _validate(_marginFeeBasisPoints <= Constants.MAX_FEE_BASIS_POINTS, 8);\n        _validate(_liquidationFeeUsd <= Constants.MAX_LIQUIDATION_FEE_USD, 9);\n        taxBasisPoints = _taxBasisPoints;\n        stableTaxBasisPoints = _stableTaxBasisPoints;\n        mintBurnFeeBasisPoints = _mintBurnFeeBasisPoints;\n        swapFeeBasisPoints = _swapFeeBasisPoints;\n        stableSwapFeeBasisPoints = _stableSwapFeeBasisPoints;\n        marginFeeBasisPoints = _marginFeeBasisPoints;\n        liquidationFeeUsd = _liquidationFeeUsd;\n        minProfitTime = _minProfitTime;\n        hasDynamicFees = _hasDynamicFees;\n    }\n    function setFundingRate(uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external override {\n        _onlyGov();\n        // TODO K\n//        _validate(_fundingInterval >= Constants.MIN_FUNDING_RATE_INTERVAL, 10);\n//        _validate(_fundingRateFactor <= Constants.MAX_FUNDING_RATE_FACTOR, 11);\n//        _validate(_stableFundingRateFactor <= Constants.MAX_FUNDING_RATE_FACTOR, 12);\n        fundingInterval = _fundingInterval;\n        fundingRateFactor = _fundingRateFactor;\n        stableFundingRateFactor = _stableFundingRateFactor;\n    }\n    function setTokenConfig(address _token, uint256 _tokenDecimals, uint256 _tokenWeight, uint256 _minProfitBps, uint256 _maxUsdmAmount, bool _isStable, bool _isShortable) external override {\n        _onlyGov();\n        if (!whitelistedTokens[_token]) {\n            whitelistedTokenCount = whitelistedTokenCount.add(1);\n            allWhitelistedTokens.push(_token);\n        }\n        uint256 _totalTokenWeights = totalTokenWeights;\n        _totalTokenWeights = _totalTokenWeights.sub(tokenWeights[_token]);\n\n        whitelistedTokens[_token] = true;\n        tokenDecimals[_token] = _tokenDecimals;\n        tokenWeights[_token] = _tokenWeight;\n        minProfitBasisPoints[_token] = _minProfitBps;\n        maxUsdmAmounts[_token] = _maxUsdmAmount;\n        stableTokens[_token] = _isStable;\n        shortableTokens[_token] = _isShortable;\n        totalTokenWeights = _totalTokenWeights.add(_tokenWeight);\n        getMaxPrice(_token);\n    }\n    function setUsdmAmount(address _token, uint256 _amount) external override {\n        _onlyGov();\n        uint256 usdmAmount = usdmAmounts[_token];\n        if (_amount > usdmAmount) {\n            _increaseUsdmAmount(_token, _amount.sub(usdmAmount));\n            return;\n        }\n        _decreaseUsdmAmount(_token, usdmAmount.sub(_amount));\n    }\n    function _validate(bool _condition, uint256 _errorCode) internal view {\n        require(_condition, errors[_errorCode]);\n    }\n    function _increaseUsdmAmount(address _token, uint256 _amount) internal {\n        usdmAmounts[_token] = usdmAmounts[_token].add(_amount);\n        uint256 maxUsdmAmount = maxUsdmAmounts[_token];\n        if (maxUsdmAmount != 0) {\n            _validate(usdmAmounts[_token] <= maxUsdmAmount, 51);\n        }\n        emit Events.IncreaseUsdmAmount(_token, _amount);\n    }\n    function _decreaseUsdmAmount(address _token, uint256 _amount) internal {\n        uint256 value = usdmAmounts[_token];\n        if (value <= _amount) {\n            usdmAmounts[_token] = 0;\n            emit Events.DecreaseUsdmAmount(_token, value);\n            return;\n        }\n        usdmAmounts[_token] = value.sub(_amount);\n        emit Events.DecreaseUsdmAmount(_token, _amount);\n    }\n    /* views */\n    function usdToTokenMin(address _token, uint256 _usdAmount) public view returns (uint256) {\n        if (_usdAmount == 0) {return 0;}\n        return usdToToken(_token, _usdAmount, getMaxPrice(_token));\n    }\n    function usdToTokenMax(address _token, uint256 _usdAmount) public view returns (uint256) {\n        if (_usdAmount == 0) {return 0;}\n        return usdToToken(_token, _usdAmount, getMinPrice(_token));\n    }\n    function tokenToUsdMin(address _token, uint256 _tokenAmount) public override view returns (uint256) {\n        if (_tokenAmount == 0) {return 0;}\n        uint256 price = getMinPrice(_token);\n        uint256 decimals = tokenDecimals[_token];\n        return _tokenAmount.mul(price).div(10 ** decimals);\n    }\n    function usdToToken(address _token, uint256 _usdAmount, uint256 _price) public view returns (uint256) {\n        if (_usdAmount == 0) {return 0;}\n        uint256 decimals = tokenDecimals[_token];\n        return _usdAmount.mul(10 ** decimals).div(_price);\n    }\n    function adjustForDecimals(uint256 _amount, address _tokenDiv, address _tokenMul) public view returns (uint256) {\n        uint256 decimalsDiv = _tokenDiv == usdm ? Constants.USDM_DECIMALS : tokenDecimals[_tokenDiv];\n        uint256 decimalsMul = _tokenMul == usdm ? Constants.USDM_DECIMALS : tokenDecimals[_tokenMul];\n        return _amount.mul(10 ** decimalsMul).div(10 ** decimalsDiv);\n    }\n    function allWhitelistedTokensLength() external override view returns (uint256) {\n        return allWhitelistedTokens.length;\n    }\n    function validateLiquidation(address _account, address _collateralToken, address _indexToken, bool _isLong, bool _raise) override public view returns (uint256, uint256) {\n        return vaultUtils.validateLiquidation(_account, _collateralToken, _indexToken, _isLong, _raise);\n    }\n    function getMaxPrice(address _token) public override view returns (uint256) {\n        return IVaultPriceFeed(priceFeed).getPrice(_token, true, includeAmmPrice, useSwapPricing);\n    }\n    function getPositionFee(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _sizeDelta) public view returns (uint256) {\n        return vaultUtils.getPositionFee(_account, _collateralToken, _indexToken, _isLong, _sizeDelta);\n    }\n    function getFundingFee(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _size, uint256 _entryFundingRate) public view returns (uint256) {\n        return vaultUtils.getFundingFee(_account, _collateralToken, _indexToken, _isLong, _size, _entryFundingRate);\n    }\n    function getMinPrice(address _token) public override view returns (uint256) {\n        return IVaultPriceFeed(priceFeed).getPrice(_token, false, includeAmmPrice, useSwapPricing);\n    }\n    function getDelta(address _indexToken, uint256 _size, uint256 _averagePrice, bool _isLong, uint256 _lastIncreasedTime) public override view returns (bool, uint256) {\n        _validate(_averagePrice > 0, 38);\n        uint256 price = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n        uint256 priceDelta = _averagePrice > price ? _averagePrice.sub(price) : price.sub(_averagePrice);\n        uint256 delta = _size.mul(priceDelta).div(_averagePrice);\n        bool hasProfit;\n        if (_isLong) {\n            hasProfit = price > _averagePrice;\n        } else {\n            hasProfit = _averagePrice > price;\n        }\n        uint256 minBps = block.timestamp > _lastIncreasedTime.add(minProfitTime) ? 0 : minProfitBasisPoints[_indexToken];\n        if (hasProfit && delta.mul(Constants.BASIS_POINTS_DIVISOR) <= _size.mul(minBps)) {\n            delta = 0;\n        }\n        return (hasProfit, delta);\n    }\n    function getPositionKey(address _account, address _collateralToken, address _indexToken, bool _isLong) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_account, _collateralToken, _indexToken, _isLong));\n    }\n    function getPosition(address _account, address _collateralToken, address _indexToken, bool _isLong) public override view returns (uint256, uint256, uint256, uint256, uint256, uint256, bool, uint256) {\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position memory position = positions[key];\n        uint256 realisedPnl = position.realisedPnl > 0 ? uint256(position.realisedPnl) : uint256(- position.realisedPnl);\n        return (position.size, position.collateral, position.averagePrice, position.entryFundingRate, position.reserveAmount, realisedPnl, position.realisedPnl >= 0, position.lastIncreasedTime);\n    }\n    function getRedemptionCollateral(address _token) public view returns (uint256) {\n        if (stableTokens[_token]) {\n            return poolAmounts[_token];\n        }\n        uint256 collateral = usdToTokenMin(_token, guaranteedUsd[_token]);\n        return collateral.add(poolAmounts[_token]).sub(reservedAmounts[_token]);\n    }\n    function getRedemptionCollateralUsd(address _token) public view returns (uint256) {\n        return tokenToUsdMin(_token, getRedemptionCollateral(_token));\n    }\n    function getRedemptionAmount(address _token, uint256 _usdmAmount) public override view returns (uint256) {\n        uint256 price = getMaxPrice(_token);\n        uint256 redemptionAmount = _usdmAmount.mul(Constants.PRICE_PRECISION).div(price);\n        return adjustForDecimals(redemptionAmount, usdm, _token);\n    }\n    function getFeeBasisPoints(address _token, uint256 _usdmDelta, uint256 _feeBasisPoints, uint256 _taxBasisPoints, bool _increment) public override view returns (uint256) {\n        return vaultUtils.getFeeBasisPoints(_token, _usdmDelta, _feeBasisPoints, _taxBasisPoints, _increment);\n    }\n    function getTargetUsdmAmount(address _token) public override view returns (uint256) {\n        uint256 supply = IERC20(usdm).totalSupply();\n        if (supply == 0) {return 0;}\n        uint256 weight = tokenWeights[_token];\n        return weight.mul(supply).div(totalTokenWeights);\n    }\n    function getEntryFundingRate(address _collateralToken, address _indexToken, bool _isLong) public view returns (uint256) {\n        return vaultUtils.getEntryFundingRate(_collateralToken, _indexToken, _isLong);\n    }\n    function getPositionDelta(address _account, address _collateralToken, address _indexToken, bool _isLong) public view returns (bool, uint256) {\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position memory position = positions[key];\n        return getDelta(_indexToken, position.size, position.averagePrice, _isLong, position.lastIncreasedTime);\n    }\n    function getGlobalShortDelta(address _token) public view returns (bool, uint256) {\n        uint256 size = globalShortSizes[_token];\n        if (size == 0) {return (false, 0);}\n        uint256 nextPrice = getMaxPrice(_token);\n        uint256 averagePrice = globalShortAveragePrices[_token];\n        uint256 priceDelta = averagePrice > nextPrice ? averagePrice.sub(nextPrice) : nextPrice.sub(averagePrice);\n        uint256 delta = size.mul(priceDelta).div(averagePrice);\n        bool hasProfit = averagePrice > nextPrice;\n        return (hasProfit, delta);\n    }\n    function getNextGlobalShortAveragePrice(address _indexToken, uint256 _nextPrice, uint256 _sizeDelta) public view returns (uint256) {\n        uint256 size = globalShortSizes[_indexToken];\n        uint256 averagePrice = globalShortAveragePrices[_indexToken];\n        uint256 priceDelta = averagePrice > _nextPrice ? averagePrice.sub(_nextPrice) : _nextPrice.sub(averagePrice);\n        uint256 delta = size.mul(priceDelta).div(averagePrice);\n        bool hasProfit = averagePrice > _nextPrice;\n        uint256 nextSize = size.add(_sizeDelta);\n        uint256 divisor = hasProfit ? nextSize.sub(delta) : nextSize.add(delta);\n        return _nextPrice.mul(nextSize).div(divisor);\n    }\n    function getPositionLeverage(address _account, address _collateralToken, address _indexToken, bool _isLong) public view returns (uint256) {\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position memory position = positions[key];\n        _validate(position.collateral > 0, 37);\n        return position.size.mul(Constants.BASIS_POINTS_DIVISOR).div(position.collateral);\n    }\n    function getNextAveragePrice(address _indexToken, uint256 _size, uint256 _averagePrice, bool _isLong, uint256 _nextPrice, uint256 _sizeDelta, uint256 _lastIncreasedTime) public view returns (uint256) {\n        (bool hasProfit, uint256 delta) = getDelta(_indexToken, _size, _averagePrice, _isLong, _lastIncreasedTime);\n        uint256 nextSize = _size.add(_sizeDelta);\n        uint256 divisor;\n        if (_isLong) {\n            divisor = hasProfit ? nextSize.add(delta) : nextSize.sub(delta);\n        } else {\n            divisor = hasProfit ? nextSize.sub(delta) : nextSize.add(delta);\n        }\n        return _nextPrice.mul(nextSize).div(divisor);\n    }\n    function getUtilisation(address _token) public view returns (uint256) {\n        uint256 poolAmount = poolAmounts[_token];\n        if (poolAmount == 0) {return 0;}\n        return reservedAmounts[_token].mul(Constants.FUNDING_RATE_PRECISION).div(poolAmount);\n    }\n    function getNextFundingRate(address _token) public override view returns (uint256) {\n        if (lastFundingTimes[_token].add(fundingInterval) > block.timestamp) {return 0;}\n        uint256 intervals = block.timestamp.sub(lastFundingTimes[_token]).div(fundingInterval);\n        uint256 poolAmount = poolAmounts[_token];\n        if (poolAmount == 0) {return 0;}\n        uint256 _fundingRateFactor = stableTokens[_token] ? stableFundingRateFactor : fundingRateFactor;\n        return _fundingRateFactor.mul(reservedAmounts[_token]).mul(intervals).div(poolAmount);\n    }\n}\n"
    },
    "contracts/core/settings/VaultInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./VaultSettings.sol\";\nabstract contract VaultInternal is VaultSettings {\n    function _reduceCollateral(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong) internal returns (uint256, uint256) {\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position storage position = positions[key];\n        uint256 fee = _collectMarginFees(_account, _collateralToken, _indexToken, _isLong, _sizeDelta, position.size, position.entryFundingRate);\n        bool hasProfit;\n        uint256 adjustedDelta;\n        {\n            (bool _hasProfit, uint256 delta) = getDelta(_indexToken, position.size, position.averagePrice, _isLong, position.lastIncreasedTime);\n            hasProfit = _hasProfit;\n            adjustedDelta = _sizeDelta.mul(delta).div(position.size);\n        }\n        uint256 usdOut;\n        if (hasProfit && adjustedDelta > 0) {\n            usdOut = adjustedDelta;\n            position.realisedPnl = position.realisedPnl + int256(adjustedDelta);\n            if (!_isLong) {\n                uint256 tokenAmount = usdToTokenMin(_collateralToken, adjustedDelta);\n                _decreasePoolAmount(_collateralToken, tokenAmount);\n            }\n        }\n        if (!hasProfit && adjustedDelta > 0) {\n            position.collateral = position.collateral.sub(adjustedDelta);\n            if (!_isLong) {\n                uint256 tokenAmount = usdToTokenMin(_collateralToken, adjustedDelta);\n                _increasePoolAmount(_collateralToken, tokenAmount);\n            }\n            position.realisedPnl = position.realisedPnl - int256(adjustedDelta);\n        }\n        if (_collateralDelta > 0) {\n            usdOut = usdOut.add(_collateralDelta);\n            position.collateral = position.collateral.sub(_collateralDelta);\n        }\n        if (position.size == _sizeDelta) {\n            usdOut = usdOut.add(position.collateral);\n            position.collateral = 0;\n        }\n        uint256 usdOutAfterFee = usdOut;\n        if (usdOut > fee) {\n            usdOutAfterFee = usdOut.sub(fee);\n        } else {\n            position.collateral = position.collateral.sub(fee);\n            if (_isLong) {\n                uint256 feeTokens = usdToTokenMin(_collateralToken, fee);\n                _decreasePoolAmount(_collateralToken, feeTokens);\n            }\n        }\n        emit Events.UpdatePnl(key, hasProfit, adjustedDelta);\n        return (usdOut, usdOutAfterFee);\n    }\n    function _collectSwapFees(address _token, uint256 _amount, uint256 _feeBasisPoints) internal returns (uint256) {\n        uint256 afterFeeAmount = _amount.mul(Constants.BASIS_POINTS_DIVISOR.sub(_feeBasisPoints)).div(Constants.BASIS_POINTS_DIVISOR);\n        uint256 feeAmount = _amount.sub(afterFeeAmount);\n        feeReserves[_token] = feeReserves[_token].add(feeAmount);\n        emit Events.CollectSwapFees(_token, tokenToUsdMin(_token, feeAmount), feeAmount);\n        return afterFeeAmount;\n    }\n    function _collectMarginFees(address _account, address _collateralToken, address _indexToken, bool _isLong, uint256 _sizeDelta, uint256 _size, uint256 _entryFundingRate) internal returns (uint256) {\n        uint256 feeUsd = getPositionFee(_account, _collateralToken, _indexToken, _isLong, _sizeDelta);\n        uint256 fundingFee = getFundingFee(_account, _collateralToken, _indexToken, _isLong, _size, _entryFundingRate);\n        feeUsd = feeUsd.add(fundingFee);\n        uint256 feeTokens = usdToTokenMin(_collateralToken, feeUsd);\n        feeReserves[_collateralToken] = feeReserves[_collateralToken].add(feeTokens);\n        emit Events.CollectMarginFees(_collateralToken, feeUsd, feeTokens);\n        return feeUsd;\n    }\n    function _transferIn(address _token) internal returns (uint256) {\n        uint256 prevBalance = tokenBalances[_token];\n        uint256 nextBalance = IERC20(_token).balanceOf(address(this));\n        tokenBalances[_token] = nextBalance;\n        return nextBalance.sub(prevBalance);\n    }\n    function _transferOut(address _token, uint256 _amount, address _receiver) internal {\n        IERC20(_token).safeTransfer(_receiver, _amount);\n        tokenBalances[_token] = IERC20(_token).balanceOf(address(this));\n    }\n    function _updateTokenBalance(address _token) internal {\n        uint256 nextBalance = IERC20(_token).balanceOf(address(this));\n        tokenBalances[_token] = nextBalance;\n    }\n    function _increasePoolAmount(address _token, uint256 _amount) internal {\n        poolAmounts[_token] = poolAmounts[_token].add(_amount);\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        _validate(poolAmounts[_token] <= balance, 49);\n        emit Events.IncreasePoolAmount(_token, _amount);\n    }\n    function _decreasePoolAmount(address _token, uint256 _amount) internal {\n        poolAmounts[_token] = poolAmounts[_token].sub(_amount, Errors.VAULT_POOLAMOUNT_EXCEEDED);\n        _validate(reservedAmounts[_token] <= poolAmounts[_token], 50);\n        emit Events.DecreasePoolAmount(_token, _amount);\n    }\n    function _increaseReservedAmount(address _token, uint256 _amount) internal {\n        reservedAmounts[_token] = reservedAmounts[_token].add(_amount);\n        _validate(reservedAmounts[_token] <= poolAmounts[_token], 52);\n        emit Events.IncreaseReservedAmount(_token, _amount);\n    }\n    function _decreaseReservedAmount(address _token, uint256 _amount) internal {\n        reservedAmounts[_token] = reservedAmounts[_token].sub(_amount, Errors.VAULT_INSUFFICIENT_RESERVE);\n        emit Events.DecreaseReservedAmount(_token, _amount);\n    }\n    function _increaseGuaranteedUsd(address _token, uint256 _usdAmount) internal {\n        guaranteedUsd[_token] = guaranteedUsd[_token].add(_usdAmount);\n        emit Events.IncreaseGuaranteedUsd(_token, _usdAmount);\n    }\n    function _decreaseGuaranteedUsd(address _token, uint256 _usdAmount) internal {\n        guaranteedUsd[_token] = guaranteedUsd[_token].sub(_usdAmount);\n        emit Events.DecreaseGuaranteedUsd(_token, _usdAmount);\n    }\n    function _increaseGlobalShortSize(address _token, uint256 _amount) internal {\n        globalShortSizes[_token] = globalShortSizes[_token].add(_amount);\n        uint256 maxSize = maxGlobalShortSizes[_token];\n        if (maxSize != 0) {\n            require(globalShortSizes[_token] <= maxSize, Errors.VAULT_MAX_SHORTS_EXCEEDED);\n        }\n    }\n    function _decreaseGlobalShortSize(address _token, uint256 _amount) internal {\n        uint256 size = globalShortSizes[_token];\n        if (_amount > size) {\n            globalShortSizes[_token] = 0;\n            return;\n        }\n        globalShortSizes[_token] = size.sub(_amount);\n    }\n    function _validateManager() internal view {\n        if (inManagerMode) {\n            _validate(isManager[msg.sender], 54);\n        }\n    }\n    function _validateGasPrice() internal view {\n        if (maxGasPrice == 0) {return;}\n        _validate(tx.gasprice <= maxGasPrice, 55);\n    }\n    function _validatePosition(uint256 _size, uint256 _collateral) internal view {\n        if (_size == 0) {\n            _validate(_collateral == 0, 39);\n            return;\n        }\n        _validate(_size >= _collateral, 40);\n    }\n    function _validateRouter(address _account) internal view {\n        if (msg.sender == _account) {return;}\n        if (msg.sender == router) {return;}\n        _validate(approvedRouters[_account][msg.sender], 41);\n    }\n    function _validateTokens(address _collateralToken, address _indexToken, bool _isLong) internal view {\n        if (_isLong) {\n            _validate(_collateralToken == _indexToken, 42);\n            _validate(whitelistedTokens[_collateralToken], 43);\n            _validate(!stableTokens[_collateralToken], 44);\n            return;\n        }\n        _validate(whitelistedTokens[_collateralToken], 45);\n        _validate(stableTokens[_collateralToken], 46);\n        _validate(!stableTokens[_indexToken], 47);\n        _validate(shortableTokens[_indexToken], 48);\n    }\n    function _validateBufferAmount(address _token) internal view {\n        if (poolAmounts[_token] < bufferAmounts[_token]) {\n            revert(Errors.VAULT_POOLAMOUNT_BUFFER);\n        }\n    }\n}\n"
    },
    "contracts/core/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./settings/VaultInternal.sol\";\ncontract Vault is VaultInternal {\n    constructor() public {\n        gov = msg.sender;\n    }\n    function initialize(address _router, address _usdm, address _priceFeed, uint256 _liquidationFeeUsd, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external {\n        _onlyGov();\n        _validate(!isInitialized, 1);\n        isInitialized = true;\n        router = _router;\n        usdm = _usdm;\n        priceFeed = _priceFeed;\n        liquidationFeeUsd = _liquidationFeeUsd;\n        fundingRateFactor = _fundingRateFactor;\n        stableFundingRateFactor = _stableFundingRateFactor;\n    }\n    function clearTokenConfig(address _token) external {\n        _onlyGov();\n        _validate(whitelistedTokens[_token], 13);\n        totalTokenWeights = totalTokenWeights.sub(tokenWeights[_token]);\n        delete whitelistedTokens[_token];\n        delete tokenDecimals[_token];\n        delete tokenWeights[_token];\n        delete minProfitBasisPoints[_token];\n        delete maxUsdmAmounts[_token];\n        delete stableTokens[_token];\n        delete shortableTokens[_token];\n        whitelistedTokenCount = whitelistedTokenCount.sub(1);\n    }\n    function withdrawFees(address _token, address _receiver) external override returns (uint256) {\n        _onlyGov();\n        uint256 amount = feeReserves[_token];\n        if (amount == 0) {return 0;}\n        feeReserves[_token] = 0;\n        _transferOut(_token, amount, _receiver);\n        return amount;\n    }\n    function addRouter(address _router) external {\n        approvedRouters[msg.sender][_router] = true;\n    }\n    function removeRouter(address _router) external {\n        approvedRouters[msg.sender][_router] = false;\n    }\n    function upgradeVault(address _newVault, address _token, uint256 _amount) external {\n        _onlyGov();\n        IERC20(_token).safeTransfer(_newVault, _amount);\n    }\n    function directPoolDeposit(address _token) external override nonReentrant {\n        _validate(whitelistedTokens[_token], 14);\n        uint256 tokenAmount = _transferIn(_token);\n        _validate(tokenAmount > 0, 15);\n        _increasePoolAmount(_token, tokenAmount);\n        emit Events.DirectPoolDeposit(_token, tokenAmount);\n    }\n    function buyUSDM(address _token, address _receiver) external override nonReentrant returns (uint256) {\n        _validateManager();\n        _validate(whitelistedTokens[_token], 16);\n        useSwapPricing = true;\n        uint256 tokenAmount = _transferIn(_token);\n        _validate(tokenAmount > 0, 17);\n        updateCumulativeFundingRate(_token, _token);\n        uint256 price = getMinPrice(_token);\n        uint256 usdmAmount = tokenAmount.mul(price).div(Constants.PRICE_PRECISION);\n        usdmAmount = adjustForDecimals(usdmAmount, _token, usdm);\n        _validate(usdmAmount > 0, 18);\n        uint256 feeBasisPoints = vaultUtils.getBuyUsdmFeeBasisPoints(_token, usdmAmount);\n        uint256 amountAfterFees = _collectSwapFees(_token, tokenAmount, feeBasisPoints);\n        uint256 mintAmount = amountAfterFees.mul(price).div(Constants.PRICE_PRECISION);\n        mintAmount = adjustForDecimals(mintAmount, _token, usdm);\n        _increaseUsdmAmount(_token, mintAmount);\n        _increasePoolAmount(_token, amountAfterFees);\n        IUSDM(usdm).mint(_receiver, mintAmount);\n        emit Events.BuyUSDM(_receiver, _token, tokenAmount, mintAmount, feeBasisPoints);\n        useSwapPricing = false;\n        return mintAmount;\n    }\n    function sellUSDM(address _token, address _receiver) external override nonReentrant returns (uint256) {\n        _validateManager();\n        _validate(whitelistedTokens[_token], 19);\n        useSwapPricing = true;\n        uint256 usdmAmount = _transferIn(usdm);\n        _validate(usdmAmount > 0, 20);\n        updateCumulativeFundingRate(_token, _token);\n        uint256 redemptionAmount = getRedemptionAmount(_token, usdmAmount);\n        _validate(redemptionAmount > 0, 21);\n        _decreaseUsdmAmount(_token, usdmAmount);\n        _decreasePoolAmount(_token, redemptionAmount);\n        IUSDM(usdm).burn(address(this), usdmAmount);\n        _updateTokenBalance(usdm);\n\n        uint256 feeBasisPoints = vaultUtils.getSellUsdmFeeBasisPoints(_token, usdmAmount);\n        uint256 amountOut = _collectSwapFees(_token, redemptionAmount, feeBasisPoints);\n        _validate(amountOut > 0, 22);\n        _transferOut(_token, amountOut, _receiver);\n        emit Events.SellUSDM(_receiver, _token, usdmAmount, amountOut, feeBasisPoints);\n        useSwapPricing = false;\n        return amountOut;\n    }\n    function swap(address _tokenIn, address _tokenOut, address _receiver) external override nonReentrant returns (uint256) {\n        _validate(isSwapEnabled, 23);\n        _validate(whitelistedTokens[_tokenIn], 24);\n        _validate(whitelistedTokens[_tokenOut], 25);\n        _validate(_tokenIn != _tokenOut, 26);\n        useSwapPricing = true;\n        updateCumulativeFundingRate(_tokenIn, _tokenIn);\n        updateCumulativeFundingRate(_tokenOut, _tokenOut);\n        uint256 amountIn = _transferIn(_tokenIn);\n        _validate(amountIn > 0, 27);\n        uint256 priceIn = getMinPrice(_tokenIn);\n        uint256 priceOut = getMaxPrice(_tokenOut);\n        uint256 amountOut = amountIn.mul(priceIn).div(priceOut);\n        amountOut = adjustForDecimals(amountOut, _tokenIn, _tokenOut);\n        uint256 usdmAmount = amountIn.mul(priceIn).div(Constants.PRICE_PRECISION);\n        usdmAmount = adjustForDecimals(usdmAmount, _tokenIn, usdm);\n        uint256 feeBasisPoints = vaultUtils.getSwapFeeBasisPoints(_tokenIn, _tokenOut, usdmAmount);\n        uint256 amountOutAfterFees = _collectSwapFees(_tokenOut, amountOut, feeBasisPoints);\n\n        _increaseUsdmAmount(_tokenIn, usdmAmount);\n        _decreaseUsdmAmount(_tokenOut, usdmAmount);\n        _increasePoolAmount(_tokenIn, amountIn);\n        _decreasePoolAmount(_tokenOut, amountOut);\n        _validateBufferAmount(_tokenOut);\n        _transferOut(_tokenOut, amountOutAfterFees, _receiver);\n        emit Events.Swap(_receiver, _tokenIn, _tokenOut, amountIn, amountOut, amountOutAfterFees, feeBasisPoints);\n        useSwapPricing = false;\n        return amountOutAfterFees;\n    }\n    function increasePosition(address _account, address _collateralToken, address _indexToken, uint256 _sizeDelta, bool _isLong) external override nonReentrant {\n        _validate(isLeverageEnabled, 28);\n        _validateGasPrice();\n        _validateRouter(_account);\n        _validateTokens(_collateralToken, _indexToken, _isLong);\n        vaultUtils.validateIncreasePosition(_account, _collateralToken, _indexToken, _sizeDelta, _isLong);\n        updateCumulativeFundingRate(_collateralToken, _indexToken);\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position storage position = positions[key];\n        uint256 price = _isLong ? getMaxPrice(_indexToken) : getMinPrice(_indexToken);\n        if (position.size == 0) {\n            position.averagePrice = price;\n        }\n        if (position.size > 0 && _sizeDelta > 0) {\n            position.averagePrice = getNextAveragePrice(_indexToken, position.size, position.averagePrice, _isLong, price, _sizeDelta, position.lastIncreasedTime);\n        }\n\n        uint256 fee = _collectMarginFees(_account, _collateralToken, _indexToken, _isLong, _sizeDelta, position.size, position.entryFundingRate);\n        uint256 collateralDelta = _transferIn(_collateralToken);\n        uint256 collateralDeltaUsd = tokenToUsdMin(_collateralToken, collateralDelta);\n        \n        position.collateral = position.collateral.add(collateralDeltaUsd);\n        _validate(position.collateral >= fee, 29);\n        position.collateral = position.collateral.sub(fee);\n        position.entryFundingRate = getEntryFundingRate(_collateralToken, _indexToken, _isLong);\n        position.size = position.size.add(_sizeDelta);\n        position.lastIncreasedTime = block.timestamp;\n        \n        _validate(position.size > 0, 30);\n        _validatePosition(position.size, position.collateral);\n        validateLiquidation(_account, _collateralToken, _indexToken, _isLong, true);\n        \n        uint256 reserveDelta = usdToTokenMax(_collateralToken, _sizeDelta);\n        position.reserveAmount = position.reserveAmount.add(reserveDelta);\n        _increaseReservedAmount(_collateralToken, reserveDelta);\n        if (_isLong) {\n            _increaseGuaranteedUsd(_collateralToken, _sizeDelta.add(fee));\n            _decreaseGuaranteedUsd(_collateralToken, collateralDeltaUsd);\n            _increasePoolAmount(_collateralToken, collateralDelta);\n            _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, fee));\n        } else {\n            if (globalShortSizes[_indexToken] == 0) {\n                globalShortAveragePrices[_indexToken] = price;\n            } else {\n                globalShortAveragePrices[_indexToken] = getNextGlobalShortAveragePrice(_indexToken, price, _sizeDelta);\n            }\n\n            _increaseGlobalShortSize(_indexToken, _sizeDelta);\n        }\n        emit Events.IncreasePosition(key, _account, _collateralToken, _indexToken, collateralDeltaUsd, _sizeDelta, _isLong, price, fee);\n        emit Events.UpdatePosition(key, position.size, position.collateral, position.averagePrice, position.entryFundingRate, position.reserveAmount, position.realisedPnl, price);\n\n        //        console.logBytes32(key);\n        //        console.log(position.size);\n        //        console.log(position.collateral);\n        //        console.log(position.averagePrice);\n        //        console.log(position.entryFundingRate);\n        //        console.log(position.reserveAmount);\n        //        console.logInt(position.realisedPnl);\n        //        console.log(position.lastIncreasedTime);\n    }\n    function decreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) external override nonReentrant returns (uint256) {\n        _validateGasPrice();\n        _validateRouter(_account);\n        return _decreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n    }\n    function liquidatePosition(address _account, address _collateralToken, address _indexToken, bool _isLong, address _feeReceiver) external override nonReentrant {\n        if (inPrivateLiquidationMode) {\n            _validate(isLiquidator[msg.sender], 34);\n        }\n        includeAmmPrice = false;\n        updateCumulativeFundingRate(_collateralToken, _indexToken);\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position memory position = positions[key];\n        _validate(position.size > 0, 35);\n        (uint256 liquidationState, uint256 marginFees) = validateLiquidation(_account, _collateralToken, _indexToken, _isLong, false);\n        _validate(liquidationState != 0, 36);\n        if (liquidationState == 2) {\n            _decreasePosition(_account, _collateralToken, _indexToken, 0, position.size, _isLong, _account);\n            includeAmmPrice = true;\n            return;\n        }\n        uint256 feeTokens = usdToTokenMin(_collateralToken, marginFees);\n        feeReserves[_collateralToken] = feeReserves[_collateralToken].add(feeTokens);\n        emit Events.CollectMarginFees(_collateralToken, marginFees, feeTokens);\n        _decreaseReservedAmount(_collateralToken, position.reserveAmount);\n\n        if (_isLong) {\n            _decreaseGuaranteedUsd(_collateralToken, position.size.sub(position.collateral));\n            _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, marginFees));\n        }\n        uint256 markPrice = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n        emit Events.LiquidatePosition(key, _account, _collateralToken, _indexToken, _isLong, position.size, position.collateral, position.reserveAmount, position.realisedPnl, markPrice);\n        if (!_isLong && marginFees < position.collateral) {\n            uint256 remainingCollateral = position.collateral.sub(marginFees);\n            _increasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, remainingCollateral));\n        }\n        if (!_isLong) {\n            _decreaseGlobalShortSize(_indexToken, position.size);\n        }\n        delete positions[key];\n        _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, liquidationFeeUsd));\n        _transferOut(_collateralToken, usdToTokenMin(_collateralToken, liquidationFeeUsd), _feeReceiver);\n        includeAmmPrice = true;\n    }\n    function updateCumulativeFundingRate(address _collateralToken, address _indexToken) public {\n        bool shouldUpdate = vaultUtils.updateCumulativeFundingRate(_collateralToken, _indexToken);\n        if (!shouldUpdate) {\n            return;\n        }\n        if (lastFundingTimes[_collateralToken] == 0) {\n            lastFundingTimes[_collateralToken] = block.timestamp.div(fundingInterval).mul(fundingInterval);\n            return;\n        }\n        if (lastFundingTimes[_collateralToken].add(fundingInterval) > block.timestamp) {\n            return;\n        }\n        uint256 fundingRate = getNextFundingRate(_collateralToken);\n        cumulativeFundingRates[_collateralToken] = cumulativeFundingRates[_collateralToken].add(fundingRate);\n        lastFundingTimes[_collateralToken] = block.timestamp.div(fundingInterval).mul(fundingInterval);\n        emit Events.UpdateFundingRate(_collateralToken, cumulativeFundingRates[_collateralToken]);\n    }\n    function _decreasePosition(address _account, address _collateralToken, address _indexToken, uint256 _collateralDelta, uint256 _sizeDelta, bool _isLong, address _receiver) internal returns (uint256) {\n        vaultUtils.validateDecreasePosition(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, _receiver);\n        updateCumulativeFundingRate(_collateralToken, _indexToken);\n        bytes32 key = getPositionKey(_account, _collateralToken, _indexToken, _isLong);\n        DataTypes.Position storage position = positions[key];\n        _validate(position.size > 0, 31);\n        _validate(position.size >= _sizeDelta, 32);\n        _validate(position.collateral >= _collateralDelta, 33);\n\n        uint256 collateral = position.collateral;\n        {\n            uint256 reserveDelta = position.reserveAmount.mul(_sizeDelta).div(position.size);\n            position.reserveAmount = position.reserveAmount.sub(reserveDelta);\n            _decreaseReservedAmount(_collateralToken, reserveDelta);\n        }\n        (uint256 usdOut, uint256 usdOutAfterFee) = _reduceCollateral(_account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong);\n        if (position.size != _sizeDelta) {\n            position.entryFundingRate = getEntryFundingRate(_collateralToken, _indexToken, _isLong);\n            position.size = position.size.sub(_sizeDelta);\n            _validatePosition(position.size, position.collateral);\n            validateLiquidation(_account, _collateralToken, _indexToken, _isLong, true);\n            if (_isLong) {\n                _increaseGuaranteedUsd(_collateralToken, collateral.sub(position.collateral));\n                _decreaseGuaranteedUsd(_collateralToken, _sizeDelta);\n            }\n            uint256 price = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n            emit Events.DecreasePosition(key, _account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, price, usdOut.sub(usdOutAfterFee));\n            emit Events.UpdatePosition(key, position.size, position.collateral, position.averagePrice, position.entryFundingRate, position.reserveAmount, position.realisedPnl, price);\n        } else {\n            if (_isLong) {\n                _increaseGuaranteedUsd(_collateralToken, collateral);\n                _decreaseGuaranteedUsd(_collateralToken, _sizeDelta);\n            }\n            uint256 price = _isLong ? getMinPrice(_indexToken) : getMaxPrice(_indexToken);\n            emit Events.DecreasePosition(key, _account, _collateralToken, _indexToken, _collateralDelta, _sizeDelta, _isLong, price, usdOut.sub(usdOutAfterFee));\n            emit Events.ClosePosition(key, position.size, position.collateral, position.averagePrice, position.entryFundingRate, position.reserveAmount, position.realisedPnl);\n            delete positions[key];\n        }\n        if (!_isLong) {\n            _decreaseGlobalShortSize(_indexToken, _sizeDelta);\n        }\n        if (usdOut > 0) {\n            if (_isLong) {\n                _decreasePoolAmount(_collateralToken, usdToTokenMin(_collateralToken, usdOut));\n            }\n            uint256 amountOutAfterFees = usdToTokenMin(_collateralToken, usdOutAfterFee);\n            _transferOut(_collateralToken, amountOutAfterFees, _receiver);\n            return amountOutAfterFees;\n        }\n        return 0;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}